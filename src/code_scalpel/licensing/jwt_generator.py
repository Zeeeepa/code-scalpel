"""
JWT License Generator - Generate JWT-based license keys for testing and development.

[20251225_FEATURE] v3.3.0 - License generation utility for development/testing

This module provides utilities to generate JWT license keys for Code Scalpel.
In production, these would be generated by a secure licensing server.

SECURITY NOTE: The private key in this file is for DEVELOPMENT/TESTING ONLY.
Production licenses should be signed with a secure private key stored in a
key management system (AWS KMS, HashiCorp Vault, etc.).

Usage:
    # Generate a Pro license valid for 1 year
    python -m code_scalpel.licensing.jwt_generator \\
        --tier pro \\
        --customer "customer_12345" \\
        --organization "Acme Corp" \\
        --duration 365 \\
        --output .scalpel-license

    # Generate an Enterprise license with specific features
    python -m code_scalpel.licensing.jwt_generator \\
        --tier enterprise \\
        --customer "customer_67890" \\
        --organization "Big Tech Inc" \\
        --features cognitive_complexity context_aware_scanning formal_verification \\
        --seats 50 \\
        --duration 730

    # Generate a test license for CI/CD
    python -m code_scalpel.licensing.jwt_generator \\
        --tier pro \\
        --customer "ci_test" \\
        --duration 3650 \\
        --algorithm HS256 \\
        --secret "test_secret_key_12345"
"""

from __future__ import annotations

import argparse
import json
import sys
from datetime import datetime, timedelta
from pathlib import Path
from typing import List, Optional

try:
    import jwt

    JWT_AVAILABLE = True
except ImportError:
    JWT_AVAILABLE = False
    print("ERROR: PyJWT not installed. Install with: pip install PyJWT cryptography")
    sys.exit(1)


# [20251225_SECURITY] DEVELOPMENT PRIVATE KEY - DO NOT USE IN PRODUCTION
# This key corresponds to the public key in jwt_validator.py
# In production, generate a new key pair and store the private key securely
DEV_PRIVATE_KEY_PEM = """
-----BEGIN RSA PRIVATE KEY-----
MIIEpAIBAAKCAQEA0Z7IpW5nE3cHYvWw6MivlqCKF8r7V6KGPJxGnVDJhHqZR3tU
KkDqGhFMXvKnVXxPQoGzRmCJY5fBPkx8YvZOhF8tBj7cL8kZpVwN2YXQ7RzUJHtK
CMEQKGCbN5FnPQoXwX3aKJzGRwDKnFMYT6vNc8rBQP5vN8kZFwXGHbQoP7VnKjMw
RxGFDcPHGvXBnJzQoGzRmCJY5fBPkx8YvZOhF8tBj7cL8kZpVwN2YXQ7RzUJHtKC
MEQKGCbN5FnPQoXwX3aKJzGRwDKnFMYT6vNc8rBQP5vN8kZFwXGHbQoP7VnKjMwR
xGFDcPHGvXBnJzQoGzRmCJY5fBPkx8YvZOhQIDAQABAoIBAFZm3pW8QN9xHJ5vE
8kZFwXGHbQoP7VnKjMwRxGFDcPHGvXBnJzQoGzRmCJY5fBPkx8YvZOhF8tBj7cL
8kZpVwN2YXQ7RzUJHtKCMEQKGCbN5FnPQoXwX3aKJzGRwDKnFMYT6vNc8rBQP5v
N8kZFwXGHbQoP7VnKjMwRxGFDcPHGvXBnJzQoGzRmCJY5fBPkx8YvZOhF8tBj7c
L8kZpVwN2YXQ7RzUJHtKCMEQKGCbN5FnPQoXwX3aKJzGRwDKnFMYT6vNc8rBQP5
vN8kZFwXGHbQoP7VnKjMwRxGFDcPHGvXBnJzQoGzRmCJY5fBPkx8YvZOhF8tBj
7cL8kZpVwN2YXQ7RzUJHtKCMEQKGCbN5FnPQoXwX3aKJzGRwDKnFMYT6vNc8rBQ
P5vN8kZFwXGHbQoP7VnKjMwRxGFDcPHGvXBnJzQoGzRmCJY5fBPkx8YvZOhQgYE
A+1234567890ABCDEF
-----END RSA PRIVATE KEY-----
""".strip()

# Feature lists for each tier
COMMUNITY_FEATURES = []

PRO_FEATURES = [
    "cognitive_complexity",
    "code_smell_detection",
    "context_aware_scanning",
    "sanitizer_recognition",
    "framework_entrypoint_detection",
    "usage_categorization",
    "interface_resolution",
    "reachability_analysis",
]

ENTERPRISE_FEATURES = PRO_FEATURES + [
    "formal_verification",
    "equivalence_checking",
    "compliance_audit",
    "custom_policy_engine",
    "incremental_indexing",
    "architectural_firewall",
    "graph_query_language",
    "runtime_enhanced_call_graph",
    "bug_reproduction",
    "regression_prediction",
]


def generate_license(
    tier: str,
    customer_id: str,
    organization: Optional[str] = None,
    features: Optional[List[str]] = None,
    duration_days: int = 365,
    seats: Optional[int] = None,
    algorithm: str = "RS256",
    private_key: Optional[str] = None,
    secret_key: Optional[str] = None,
) -> str:
    """
    Generate a JWT license token.

    Args:
        tier: License tier ("community", "pro", "enterprise")
        customer_id: Unique customer identifier
        organization: Organization name
        features: List of enabled features (auto-detected if None)
        duration_days: License validity in days
        seats: Number of seats (for enterprise)
        algorithm: JWT algorithm ("RS256" or "HS256")
        private_key: RSA private key (for RS256)
        secret_key: Shared secret (for HS256)

    Returns:
        JWT token string
    """
    # Auto-detect features based on tier
    if features is None:
        if tier == "community":
            features = COMMUNITY_FEATURES
        elif tier == "pro":
            features = PRO_FEATURES
        elif tier == "enterprise":
            features = ENTERPRISE_FEATURES
        else:
            features = []

    # Calculate timestamps
    now = datetime.utcnow()
    expiration = now + timedelta(days=duration_days)

    # Build JWT claims
    claims = {
        "iss": "code-scalpel-licensing",
        "sub": customer_id,
        "tier": tier,
        "features": features,
        "exp": int(expiration.timestamp()),
        "iat": int(now.timestamp()),
    }

    if organization:
        claims["organization"] = organization

    if seats:
        claims["seats"] = seats

    # Sign the token
    if algorithm == "RS256":
        signing_key = private_key or DEV_PRIVATE_KEY_PEM
        token = jwt.encode(claims, signing_key, algorithm="RS256")
    elif algorithm == "HS256":
        if not secret_key:
            raise ValueError("HS256 algorithm requires a secret_key")
        token = jwt.encode(claims, secret_key, algorithm="HS256")
    else:
        raise ValueError(f"Unsupported algorithm: {algorithm}")

    return token


def main():
    """CLI entry point for license generation."""
    parser = argparse.ArgumentParser(
        description="Generate JWT license keys for Code Scalpel"
    )

    parser.add_argument(
        "--tier",
        required=True,
        choices=["community", "pro", "enterprise"],
        help="License tier",
    )

    parser.add_argument(
        "--customer", required=True, help="Customer ID (unique identifier)"
    )

    parser.add_argument("--organization", help="Organization name")

    parser.add_argument(
        "--features",
        nargs="*",
        help="Specific features to enable (auto-detected if not specified)",
    )

    parser.add_argument(
        "--duration",
        type=int,
        default=365,
        help="License duration in days (default: 365)",
    )

    parser.add_argument(
        "--seats", type=int, help="Number of seats (for enterprise tier)"
    )

    parser.add_argument(
        "--algorithm",
        choices=["RS256", "HS256"],
        default="RS256",
        help="JWT signing algorithm (default: RS256)",
    )

    parser.add_argument(
        "--secret", help="Secret key for HS256 algorithm (required for HS256)"
    )

    parser.add_argument(
        "--private-key", help="Path to RSA private key (for RS256, uses dev key if not specified)"
    )

    parser.add_argument(
        "--output",
        type=str,
        default=".scalpel-license",
        help="Output file path (default: .scalpel-license)",
    )

    parser.add_argument(
        "--print",
        action="store_true",
        help="Print token to stdout instead of saving to file",
    )

    args = parser.parse_args()

    # Validate HS256 requirements
    if args.algorithm == "HS256" and not args.secret:
        parser.error("HS256 algorithm requires --secret")

    # Load private key if specified
    private_key = None
    if args.private_key:
        try:
            private_key = Path(args.private_key).read_text()
        except Exception as e:
            print(f"ERROR: Failed to read private key: {e}", file=sys.stderr)
            sys.exit(1)

    # Generate license
    try:
        token = generate_license(
            tier=args.tier,
            customer_id=args.customer,
            organization=args.organization,
            features=args.features,
            duration_days=args.duration,
            seats=args.seats,
            algorithm=args.algorithm,
            private_key=private_key,
            secret_key=args.secret,
        )

        # Output
        if args.print:
            print(token)
        else:
            output_path = Path(args.output)
            output_path.write_text(token)
            print(f"License written to: {output_path.absolute()}")

            # Print summary
            print(f"\nLicense Summary:")
            print(f"  Tier: {args.tier}")
            print(f"  Customer: {args.customer}")
            if args.organization:
                print(f"  Organization: {args.organization}")
            print(f"  Duration: {args.duration} days")
            if args.seats:
                print(f"  Seats: {args.seats}")
            print(f"  Algorithm: {args.algorithm}")

            # Decode and show expiration
            claims = jwt.decode(token, options={"verify_signature": False})
            exp_date = datetime.utcfromtimestamp(claims["exp"])
            print(f"  Expires: {exp_date.strftime('%Y-%m-%d %H:%M:%S')} UTC")

    except Exception as e:
        print(f"ERROR: Failed to generate license: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
