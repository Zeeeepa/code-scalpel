{
  "generatedAt": "2026-01-14",
  "source": {
    "matrix": "docs/tools/deep_dive/TOOL_CAPABILITY_MATRIX.md",
    "deepDiveDir": "docs/tools/deep_dive"
  },
  "tools": [
    {
      "name": "analyze_code",
      "status": "\u2705 Stable",
      "tierAvailability": "All (Comm/Pro/Ent)",
      "keyCapabilities": [
        "AST Parsing / Tree-sitter",
        "Zero Hallucination Structure",
        "Complexity Metrics"
      ],
      "purpose": "The analyze_code MCP tool provides static (non-executing) code structure analysis across multiple programming languages. It serves as the primary entry point for understanding code before performing surgical operations. Unlike text-based analysis or LLM inference, this tool uses real language parsers (Python AST, tree-sitter for JavaScript/TypeScript, dedicated Java analyzer) to extract functions, classes, imports, and compute complexity metrics with zero hallucination risk. It is explicitly not a vulnerability scanner\u2014use security_scan for that purpose.",
      "keyBenefits": [
        "Zero Hallucination Risk: Uses real parsers (Python ast, tree-sitter), not pattern matching or LLM inference",
        "Multi-Language Support: Python, JavaScript, TypeScript, Java with consistent JSON output",
        "Tier-Based Features: Progressive enhancement from basic structure (Community) to AI-enhanced analysis (Enterprise)",
        "Token Efficient: Returns structured data (~200 tokens) vs requiring AI to parse full file content (~5,000+ tokens)",
        "Fast Analysis: Sub-100ms parsing for typical files (<1,000 LOC)",
        "No Code Execution: Parsing only\u2014zero security risk from malicious code"
      ],
      "whenToUse": [
        "Primary Use Case: Understanding code structure before extraction, modification, or deeper analysis",
        "Secondary Use Cases:",
        "Inventory functions/classes in a file",
        "Calculate complexity metrics (cyclomatic, cognitive)",
        "Identify code smells and technical debt (Pro/Enterprise)",
        "Validate syntax before processing"
      ],
      "notSuitableFor": [],
      "signature": "",
      "toolVersion": "",
      "lastUpdated": "",
      "deepDiveFile": "ANALYZE_CODE_DEEP_DIVE.md",
      "deepDiveUrl": "https://github.com/tescolopio/code-scalpel/blob/main/docs/tools/deep_dive/ANALYZE_CODE_DEEP_DIVE.md"
    },
    {
      "name": "code_policy_check",
      "status": "\u2705 Stable",
      "tierAvailability": "All (Comm/Pro/Ent)",
      "keyCapabilities": [
        "Style + Security + Compliance",
        "HIPAA/SOC2 Enforcement (Ent)",
        "Automated Fixes"
      ],
      "purpose": "The code_policy_check MCP tool enforces organizational coding standards, best practices, and compliance requirements across your codebase. Unlike style-only linters (ESLint, pylint), this tool combines style checks with best practice patterns, security anti-patterns, and compliance auditing in a single unified interface. It is purpose-built for governance, not just code cleanliness\u2014designed to help teams enforce organizational standards consistently and audit compliance with regulations (HIPAA, SOC2, GDPR, PCI-DSS).",
      "keyBenefits": [
        "Single Unified Interface: Combines style (PEP8/ESLint), best practices, security patterns, and compliance checks in one tool",
        "Tier-Based Enforcement: Community gets style basics, Pro adds best practices and security, Enterprise adds compliance auditing",
        "Organization-Centric: Custom rules, policy inheritance, and audit trails for governance",
        "Compliance-Ready: Built-in mappings for HIPAA, SOC2, GDPR, PCI-DSS with PDF certification generation",
        "Actionable Output: Clear violation descriptions with suggested fixes (Pro/Enterprise)",
        "Governance Focus: Audit trail tracking for compliance evidence, policy versioning, and change control"
      ],
      "whenToUse": [
        "Primary Use Case: Enforce organizational coding standards and detect violations at scale",
        "Secondary Use Cases:",
        "Compliance auditing (HIPAA, SOC2, GDPR, PCI-DSS) (Enterprise)",
        "Security pattern enforcement (hardcoded secrets, SQL injection patterns) (Pro/Enterprise)",
        "Best practice enforcement (type hints, docstrings, function length) (Pro/Enterprise)",
        "Code quality gates in CI/CD pipelines"
      ],
      "notSuitableFor": [],
      "signature": "",
      "toolVersion": "",
      "lastUpdated": "",
      "deepDiveFile": "CODE_POLICY_CHECK_DEEP_DIVE.md",
      "deepDiveUrl": "https://github.com/tescolopio/code-scalpel/blob/main/docs/tools/deep_dive/CODE_POLICY_CHECK_DEEP_DIVE.md"
    },
    {
      "name": "crawl_project",
      "status": "\u2705 Stable",
      "tierAvailability": "All (Comm/Pro/Ent)",
      "keyCapabilities": [
        "Project-wide Inventory",
        "Hotspot Identification",
        "Framework Detection"
      ],
      "purpose": "The crawl_project MCP tool analyzes entire project directories at once, providing comprehensive project structure, complexity metrics, and code intelligence across all files. Unlike single-file tools (analyze_code, extract_code), this tool gives you the bird's-eye view of your entire codebase\u2014file counts, complexity hotspots, framework detection, dependency mapping, and (Enterprise) compliance signals. It's designed to be the starting point for project understanding, risk assessment, and architectural analysis.",
      "keyBenefits": [
        "Project-Wide Visibility: Scan 100s to 1000s of files in one operation",
        "Hotspot Identification: Automatically find complex/risky functions requiring attention",
        "Dependency Mapping: Understand file-level import relationships (Pro/Enterprise)",
        "Framework Detection: Identify frameworks in use with confidence scoring (Pro/Enterprise)",
        "Monorepo Support: Handle multi-package repositories with module boundary detection (Enterprise)",
        "Historical Trends: Track complexity/metrics over time (Enterprise)"
      ],
      "whenToUse": [
        "Primary Use Case: Understand overall project structure and identify complexity hotspots",
        "Secondary Use Cases:",
        "Risk assessment before major refactoring",
        "Identify areas requiring security review",
        "Framework detection and dependency analysis",
        "Historical complexity tracking"
      ],
      "notSuitableFor": [],
      "signature": "",
      "toolVersion": "",
      "lastUpdated": "",
      "deepDiveFile": "CRAWL_PROJECT_DEEP_DIVE.md",
      "deepDiveUrl": "https://github.com/tescolopio/code-scalpel/blob/main/docs/tools/deep_dive/CRAWL_PROJECT_DEEP_DIVE.md"
    },
    {
      "name": "cross_file_security_scan",
      "status": "\u2705 Stable",
      "tierAvailability": "All (Comm/Pro/Ent)",
      "keyCapabilities": [
        "Taint Tracking across files",
        "Data Flow Visuals (Mermaid)",
        "Risk Assessment"
      ],
      "purpose": "The cross_file_security_scan MCP tool detects security vulnerabilities that span multiple files by tracking tainted data flow across module and file boundaries. While security_scan analyzes individual files in isolation, cross_file_security_scan answers the critical question: \"How does untrusted data flow through my entire system?\"",
      "keyBenefits": [
        "Defense in Depth: Find vulnerabilities that cross file boundaries",
        "Architecture Visibility: Understand how untrusted data flows through your system",
        "Compliance Ready: Generate audit trails for security reviews",
        "Risk Assessment: Identify highest-risk code paths for prioritized remediation",
        "Deterministic Output: Same code = same findings, stable across runs",
        "Tier-Scaled Complexity: Community gets basic cross-file flows, Enterprise gets microservice boundary tracking"
      ],
      "whenToUse": [
        "Primary Use Case: Detect cross-file security vulnerabilities and taint flows",
        "Secondary Use Cases:",
        "Code audit and compliance verification",
        "Architecture review for security risks",
        "Vulnerability remediation guidance",
        "Third-party library impact assessment"
      ],
      "notSuitableFor": [],
      "signature": "",
      "toolVersion": "",
      "lastUpdated": "",
      "deepDiveFile": "CROSS_FILE_SECURITY_SCAN_DEEP_DIVE.md",
      "deepDiveUrl": "https://github.com/tescolopio/code-scalpel/blob/main/docs/tools/deep_dive/CROSS_FILE_SECURITY_SCAN_DEEP_DIVE.md"
    },
    {
      "name": "extract_code",
      "status": "\u2705 Stable",
      "tierAvailability": "All (Comm/Pro/Ent)",
      "keyCapabilities": [
        "Token-Efficient Extraction",
        "Precision Symbol Targeting",
        "React/JSX Metadata"
      ],
      "purpose": "The extract_code MCP tool surgically extracts specific code elements (functions, classes, methods) by name from source files with maximum token efficiency. Instead of AI agents reading entire files (consuming thousands of tokens), the server reads the file and returns only the requested symbol. This is the primary code retrieval tool for Code Scalpel, designed to eliminate line-number guessing and provide actionable context for refactoring, analysis, and modification tasks.",
      "keyBenefits": [
        "Token Efficiency: Agent sends ~50 tokens, receives ~200 (vs 10,000+ for full file)",
        "Precision: Extract by symbol name, not line numbers (no guessing)",
        "Multi-Language: Python (full AST), JavaScript/TypeScript/Java (tree-sitter parsing)",
        "Context-Aware: Optionally include intra-file dependencies (imports, helper functions)",
        "Cross-File Resolution: Pro/Enterprise can resolve imports from external files",
        "Deterministic: Same input = same output (stable across runs)"
      ],
      "whenToUse": [
        "Primary Use Case: Retrieve specific functions/classes for analysis or modification",
        "Secondary Use Cases:",
        "Understand function implementation before refactoring",
        "Extract code with dependencies for standalone testing",
        "Get React component code with metadata",
        "Retrieve Java methods or JavaScript functions"
      ],
      "notSuitableFor": [],
      "signature": "",
      "toolVersion": "",
      "lastUpdated": "",
      "deepDiveFile": "EXTRACT_CODE_DEEP_DIVE.md",
      "deepDiveUrl": "https://github.com/tescolopio/code-scalpel/blob/main/docs/tools/deep_dive/EXTRACT_CODE_DEEP_DIVE.md"
    },
    {
      "name": "generate_unit_tests",
      "status": "\u2705 Validated",
      "tierAvailability": "All (Comm/Pro/Ent)",
      "keyCapabilities": [
        "Symbolic Execution (Z3)",
        "100% Path Coverage",
        "Data-driven Tests (Pro)"
      ],
      "purpose": "The generate_unit_tests MCP tool automatically creates comprehensive unit tests from source code using symbolic execution to explore all execution paths. Instead of developers manually writing test cases for every branch, the tool generates complete test suites with concrete input values that trigger each path through the code. This is the primary test automation tool for Code Scalpel, designed to reduce test-writing boilerplate while ensuring high code coverage through path-based exploration.",
      "keyBenefits": [
        "Automatic Path Coverage: Symbolic execution explores all branches automatically",
        "Concrete Test Cases: Each test has specific input values (no placeholders)",
        "Framework Support: Generate pytest (all tiers) or unittest (Pro+) tests",
        "Data-Driven Tests: Pro tier generates parametrized tests for readability",
        "Bug Reproduction: Enterprise tier generates tests from crash logs",
        "Tier-Based Limits: Enforced limits prevent context overflow (5/20/unlimited)"
      ],
      "whenToUse": [
        "Primary Use Case: Automatically generate tests for functions with complex branching",
        "Secondary Use Cases:",
        "Bootstrap test suites for untested code",
        "Generate regression tests from bug reports (Enterprise)",
        "Create parametrized tests for readability (Pro)",
        "Explore edge cases via symbolic execution"
      ],
      "notSuitableFor": [],
      "signature": "",
      "toolVersion": "",
      "lastUpdated": "",
      "deepDiveFile": "GENERATE_UNIT_TESTS_DEEP_DIVE.md",
      "deepDiveUrl": "https://github.com/tescolopio/code-scalpel/blob/main/docs/tools/deep_dive/GENERATE_UNIT_TESTS_DEEP_DIVE.md"
    },
    {
      "name": "get_call_graph",
      "status": "\u2705 Stable",
      "tierAvailability": "All (Comm/Pro/Ent)",
      "keyCapabilities": [
        "Static Call Graphs",
        "Circular Dependency Check",
        "Visual Architecture"
      ],
      "purpose": "The get_call_graph MCP tool generates static call graphs showing function-to-function relationships, entry points, and circular dependencies across codebases. Call graphs are fundamental for understanding program structure, enabling AI agents to perform impact analysis (what breaks if I change this?), dead code detection (functions with no callers), and security auditing (trace data flow paths to sensitive sinks). This is the primary architecture visualization tool for Code Scalpel, designed to help agents navigate large codebases with surgical precision.",
      "keyBenefits": [
        "Context Window Optimization: Agents request only the transitive closure of relevant functions",
        "Safe Refactoring: Enumerate all call sites before modifying a function",
        "Security Auditing: Trace paths from untrusted inputs to dangerous sinks",
        "Architecture Understanding: Visualize module boundaries, identify god functions",
        "Circular Dependency Detection: Find import cycles and call cycles automatically",
        "Entry Point Discovery: Automatically identify CLI commands, web routes, tests"
      ],
      "whenToUse": [
        "Primary Use Case: Understand function relationships before refactoring or modification",
        "Secondary Use Cases:",
        "Impact analysis: What breaks if I change function X?",
        "Dead code detection: Functions with no incoming edges",
        "Security auditing: Trace data flow to sensitive sinks",
        "Architecture validation: Verify no calls violate layer boundaries"
      ],
      "notSuitableFor": [],
      "signature": "",
      "toolVersion": "",
      "lastUpdated": "",
      "deepDiveFile": "GET_CALL_GRAPH_DEEP_DIVE.md",
      "deepDiveUrl": "https://github.com/tescolopio/code-scalpel/blob/main/docs/tools/deep_dive/GET_CALL_GRAPH_DEEP_DIVE.md"
    },
    {
      "name": "get_cross_file_dependencies",
      "status": "\u2705 Stable",
      "tierAvailability": "All (Comm/Pro/Ent)",
      "keyCapabilities": [
        "Import Chain Resolution",
        "Transitive Extraction",
        "Confidence Scoring"
      ],
      "purpose": "The get_cross_file_dependencies tool analyzes import/require statements and traces dependency chains across file boundaries with confidence scoring. It extracts complete code context for AI-assisted editing by following import chains, resolving symbols, and providing confidence-decayed scores for deep dependencies. This is the primary tool for understanding cross-file relationships, enabling AI agents to gather all necessary code context without hallucinating dependencies or missing critical imports.",
      "keyBenefits": [
        "Complete Context Collection: Gather all code needed to understand a function across multiple files",
        "Confidence-Scored Dependencies: Exponential decay (0.9^depth) shows reliability of deep chains",
        "Circular Import Detection: Automatically identify import cycles that could cause runtime issues",
        "Combined Code Output: Ready-to-analyze code block with all dependencies included",
        "Transitive Resolution (Pro): Follow A \u2192 B \u2192 C chains to understand full dependency tree",
        "Architectural Enforcement (Enterprise): Validate layer boundaries and coupling limits"
      ],
      "whenToUse": [
        "Primary Use Case: Extract complete code context for a function/class before refactoring",
        "Secondary Use Cases:",
        "Understand what code a symbol depends on across files",
        "Detect circular import issues in Python projects",
        "Gather dependencies for AI-assisted code generation",
        "Validate architectural layer boundaries (Enterprise)"
      ],
      "notSuitableFor": [],
      "signature": "",
      "toolVersion": "",
      "lastUpdated": "",
      "deepDiveFile": "GET_CROSS_FILE_DEPENDENCIES_DEEP_DIVE.md",
      "deepDiveUrl": "https://github.com/tescolopio/code-scalpel/blob/main/docs/tools/deep_dive/GET_CROSS_FILE_DEPENDENCIES_DEEP_DIVE.md"
    },
    {
      "name": "get_file_context",
      "status": "\u2705 Stable",
      "tierAvailability": "All (Comm/Pro/Ent)",
      "keyCapabilities": [
        "\"Peek\" without Read",
        "Token Efficiency (95% savings)",
        "Security Summaries"
      ],
      "purpose": "The get_file_context tool provides a token-efficient \"strategic glance\" at a file without reading its full content. It returns a structured summary including functions, classes, imports, complexity metrics, and security warnings. This allows AI agents to rapidly assess file relevance and structure while consuming ~95% fewer tokens than a full read_file operation. It serves as a critical reconnaissance tool before performing expensive extraction or analysis tasks.",
      "keyBenefits": [
        "Token Efficiency: Returns ~50-150 tokens vs ~5,000+ for reading a full file.",
        "Safety First: Includes security warnings (CWE mapping) in all tiers.",
        "Multi-Language Support: Consistent output for Python, JavaScript, TypeScript, and Java.",
        "Tier-Based Insights: Scales from structural outlines (Community) to AI-driven intent and intent extraction (Pro) and organizational compliance (Enterprise).",
        "Introspection: Returns metadata (tier_applied, limits_applied) so agents understand their operating constraints."
      ],
      "whenToUse": [
        "Primary Use Case: Assessing file relevance before deciding to read or extract code.",
        "Secondary Use Cases:",
        "Checking for specific imports or dependencies.",
        "Identifying security hotspots (sinks) quickly.",
        "Getting a high-level summary of file intent.",
        "Not Suitable For:"
      ],
      "notSuitableFor": [],
      "signature": "async def get_file_context(\n    file_path: str,\n    # Implicit tier configuration injected by server\n) -> FileContextResult",
      "toolVersion": "",
      "lastUpdated": "",
      "deepDiveFile": "GET_FILE_CONTEXT_DEEP_DIVE.md",
      "deepDiveUrl": "https://github.com/tescolopio/code-scalpel/blob/main/docs/tools/deep_dive/GET_FILE_CONTEXT_DEEP_DIVE.md"
    },
    {
      "name": "get_graph_neighborhood",
      "status": "\u2705 Stable",
      "tierAvailability": "All (Comm/Pro/Ent)",
      "keyCapabilities": [
        "K-Hop Traversal",
        "\"Exploding Graph\" Prevention",
        "Local Architecture Viz"
      ],
      "purpose": "The get_graph_neighborhood tool addresses the \"Exploding Graph Problem\" in large-scale code analysis. Instead of processing an entire project's call graph (which can consume massive memory and tokens), it extracts a localized subgraph around a specific \"center node.\" It supports filtering by edge direction, confidence levels, and (in Enterprise tiers) a Cypher-like query language. This allows AI agents to surgically explore dependency chains without loading the entire codebase.",
      "keyBenefits": [
        "Memory Safety: Prevents Out-Of-Memory (OOM) errors by enforcing node limits and truncation protection.",
        "Focused Analysis: Restricts context to relevant k-hop neighbors (e.g., \"what calls this function directly?\").",
        "Semantic Intelligence: (Pro+) Identifies functionally similar nodes using name/docstring similarity, not just direct calls.",
        "Query Flexibility: (Enterprise) Supports complex graph traversals via a custom query language.",
        "Visual Validation: Auto-generates Mermaid diagrams for immediate visual verification of relationships."
      ],
      "whenToUse": [
        "Primary Use Case: Investigating the immediate impact of changing a specific function or class.",
        "Secondary Use Cases:",
        "Tracing data flow through a limited path.",
        "Understanding dependencies of a module without reading all files.",
        "Visualizing local architecture via Mermaid.",
        "Not Suitable For:"
      ],
      "notSuitableFor": [],
      "signature": "async def get_graph_neighborhood(\n    center_node_id: str,\n    k: int = 1,\n    max_nodes: int = 100,\n    direction: str = \"both\",\n    min_confidence: float = 0.0,\n    # Implicit tier config injected\n    **kwargs\n) -> GraphNeighborhoodResult",
      "toolVersion": "",
      "lastUpdated": "",
      "deepDiveFile": "GET_GRAPH_NEIGHBORHOOD_DEEP_DIVE.md",
      "deepDiveUrl": "https://github.com/tescolopio/code-scalpel/blob/main/docs/tools/deep_dive/GET_GRAPH_NEIGHBORHOOD_DEEP_DIVE.md"
    },
    {
      "name": "get_project_map",
      "status": "\u2705 Stable",
      "tierAvailability": "All (Comm/Pro/Ent)",
      "keyCapabilities": [
        "Architectural Reconnaissance",
        "3D City Maps (Ent)",
        "Layer Detection"
      ],
      "purpose": "The get_project_map tool is Code Scalpel's architectural reconnaissance engine that generates comprehensive project structure visualizations showing packages, modules, complexity hotspots, and architectural patterns. Unlike simple directory listings, this tool understands language-specific constructs (Python packages, JavaScript modules, Java packages), detects circular dependencies, identifies entry points, and reveals architectural layering. It serves as the critical first step for AI agents and developers approaching an unfamiliar codebase, providing the \"30,000 foot view\" before diving into specific files.",
      "keyBenefits": [
        "Context Bootstrapping: Rapidly understand codebase structure without reading every file.",
        "Architecture Awareness: Detects layered architectures (presentation, business, data layers) to guide safe modifications.",
        "Navigation Intelligence: Returns actual file paths, preventing AI agents from hallucinating non-existent locations.",
        "Technical Debt Visibility: (Pro/Enterprise) Identifies complexity hotspots, high-churn files, and bug-prone areas.",
        "Compliance Ready: (Enterprise) Maps code structure to organizational architectural rules and governance policies."
      ],
      "whenToUse": [
        "Primary Use Case: Initial orientation when working with an unfamiliar codebase.",
        "Secondary Use Cases:",
        "Generating architecture documentation (Mermaid diagrams for READMEs).",
        "Identifying where to add new features (find the right layer/package).",
        "Detecting architectural drift (comparing current vs. expected patterns).",
        "Prioritizing technical debt (complexity hotspots, churn metrics)."
      ],
      "notSuitableFor": [],
      "signature": "async def get_project_map(\n    project_root: str,\n    include_git_analysis: bool = False,\n    detail_level: Optional[str] = None,\n    compliance_rules: Optional[str] = None,\n    additional_roots: Optional[List[str]] = None,\n    # Implicit tier config injected\n    **kwargs\n) -> ProjectMapResult",
      "toolVersion": "",
      "lastUpdated": "",
      "deepDiveFile": "GET_PROJECT_MAP_DEEP_DIVE.md",
      "deepDiveUrl": "https://github.com/tescolopio/code-scalpel/blob/main/docs/tools/deep_dive/GET_PROJECT_MAP_DEEP_DIVE.md"
    },
    {
      "name": "get_symbol_references",
      "status": "\u2705 Best-in-Class",
      "tierAvailability": "All (Comm/Pro/Ent)",
      "keyCapabilities": [
        "AST-Based Reference Finding",
        "Impact Analysis",
        "Safe Refactoring Prep"
      ],
      "purpose": "The get_symbol_references MCP tool finds all references to a symbol (function, class, variable) across the project for safe refactoring and impact analysis. Unlike grep-based text search or LLM inference, this tool uses real AST parsing to guarantee accurate results\u2014excluding false positives from comments, strings, and similarly-named symbols. It answers the critical question: \"What will break if I change this?\"",
      "keyBenefits": [
        "Zero Hallucination Risk: Uses real AST parsing via Python's ast module, not pattern matching or LLM inference",
        "Safe Refactoring: Know ALL call sites before changing function signatures\u2014no surprises",
        "Impact Analysis: Understand the blast radius of changes before committing",
        "Comment/String Exclusion: Won't find \"process_order\" inside a comment or docstring",
        "Tier-Progressive Intelligence: Community gets accurate finding; Pro adds categorization; Enterprise adds risk scoring and team coordination",
        "CODEOWNERS Integration: Enterprise tier identifies stakeholders who need to review changes"
      ],
      "whenToUse": [
        "Primary Use Case: Pre-refactoring impact analysis\u2014find all usages before changing a symbol",
        "Secondary Use Cases:",
        "Understanding how a function is called throughout the codebase",
        "Finding all instantiations of a class",
        "Locating all imports of a module",
        "Identifying read vs. write patterns for variables (Pro)"
      ],
      "notSuitableFor": [],
      "signature": "",
      "toolVersion": "",
      "lastUpdated": "",
      "deepDiveFile": "GET_SYMBOL_REFERENCES_DEEP_DIVE.md",
      "deepDiveUrl": "https://github.com/tescolopio/code-scalpel/blob/main/docs/tools/deep_dive/GET_SYMBOL_REFERENCES_DEEP_DIVE.md"
    },
    {
      "name": "rename_symbol",
      "status": "\u2705 Stable",
      "tierAvailability": "All (Comm/Pro/Ent)",
      "keyCapabilities": [
        "Surgical Rename",
        "Auto-Update References",
        "Comment Preservation"
      ],
      "purpose": "The rename_symbol MCP tool safely renames functions, classes, or methods in source code while automatically updating all references throughout the codebase. Unlike simple find-and-replace, this tool uses AST-based transformation to ensure syntactic correctness, preserve formatting, and avoid false positives in strings and comments. It answers the critical question: \"How do I rename this symbol without breaking anything?\"",
      "keyBenefits": [
        "AST-Based Transformation: Uses real parsing (Python ast + tokenize, tree-sitter for JS/TS) for correctness",
        "Automatic Reference Updates: All usages of the symbol are updated, not just the definition",
        "String/Comment Preservation: Won't accidentally rename occurrences in strings or comments",
        "Syntax Validation: Validates that the new name is a legal identifier for the language",
        "Backup and Rollback: Creates backups before changes (configurable)",
        "Multi-Language Support: Python, JavaScript, TypeScript, JSX in v1.0"
      ],
      "whenToUse": [
        "Primary Use Case: Renaming functions, classes, or methods during refactoring",
        "Secondary Use Cases:",
        "Updating symbol names to match new naming conventions",
        "Fixing typos in function/class names",
        "Renaming after understanding what code actually does",
        "Batch renames across large codebases (Pro/Enterprise)"
      ],
      "notSuitableFor": [],
      "signature": "",
      "toolVersion": "",
      "lastUpdated": "",
      "deepDiveFile": "RENAME_SYMBOL_DEEP_DIVE.md",
      "deepDiveUrl": "https://github.com/tescolopio/code-scalpel/blob/main/docs/tools/deep_dive/RENAME_SYMBOL_DEEP_DIVE.md"
    },
    {
      "name": "scan_dependencies",
      "status": "\u2705 Stable",
      "tierAvailability": "All (Comm/Pro/Ent)",
      "keyCapabilities": [
        "Supply Chain Security (OSV)",
        "Reachability Analysis (Pro)",
        "License Compliance"
      ],
      "purpose": "The scan_dependencies tool performs Software Composition Analysis (SCA) to identify security risks in project dependencies. It scans manifest files (like requirements.txt, package.json, pom.xml) and checks them against the Open Source Vulnerabilities (OSV) database. Beyond simple CVE detection, it provides \"World Class\" supply chain security by detecting typosquatting, checking license compliance, and\u2014crucially\u2014performing reachability analysis to filter out false positives (vulnerable code that is never strictly imported/used).",
      "keyBenefits": [
        "Multi-Language Support: Python, JavaScript, and Java (Maven/Gradle) in a single unified tool.",
        "False Positive Reduction (Pro): Uses static analysis to determine if vulnerable libraries are actually reachable in the code.",
        "Supply Chain Defense: Detects \"typosquatting\" attacks (malicious packages mimicking popular ones) and evaluates license risks.",
        "Enterprise Compliance: Generates SOC2/ISO 27001 readiness reports and enforces organization-wide blocking policies.",
        "Tier-Based Scaling: From simple CVE checks for individuals to full compliance audits for enterprises."
      ],
      "whenToUse": [
        "Primary Use Case: Auditing a project for vulnerable outdated packages.",
        "Secondary Use Cases:",
        "Checking license compatibility (e.g., finding GPL code in proprietary projects).",
        "Preventing supply chain attacks (typosquatting detection) during development.",
        "Generating compliance artifacts (SBOMs, Policy Reports) for audits.",
        "Not Suitable For:"
      ],
      "notSuitableFor": [],
      "signature": "",
      "toolVersion": "",
      "lastUpdated": "",
      "deepDiveFile": "SCAN_DEPENDENCIES_DEEP_DIVE.md",
      "deepDiveUrl": "https://github.com/tescolopio/code-scalpel/blob/main/docs/tools/deep_dive/SCAN_DEPENDENCIES_DEEP_DIVE.md"
    },
    {
      "name": "security_scan",
      "status": "\u2705 Stable",
      "tierAvailability": "All (Comm/Pro/Ent)",
      "keyCapabilities": [
        "Single-file SAST",
        "Taint Analysis (Python)",
        "Polyglot Sink Detection"
      ],
      "purpose": "The security_scan tool is the primary Single-File Static Application Security Testing (SAST) engine in Code Scalpel. It identifies critical security vulnerabilities\u2014such as SQL Injection, XSS, and Command Injection\u2014by analyzing source code without executing it. For Python, it utilizes sophisticated Taint Analysis to track dangerous data flows from sources (inputs) to sinks (vulnerable functions), significantly reducing false positives compared to simple regex scanners. For JavaScript, TypeScript, and Java, it enforces strict Sink Detection to flag dangerous patterns.",
      "keyBenefits": [
        "Zero Execution Risk: Analyzes ASTs statically; never executes potentially malicious code.",
        "High Precision (Python): Uses data flow analysis to understand if input is sanitized before use.",
        "Polyglot Support: Covers Python (Full Taint), JavaScript, TypeScript, and Java (Sink Detection).",
        "Compliance Ready: Maps all findings to standard Weakness Enumerations (CWE) and OWASP Top 10 categories.",
        "Educational: Pro tier provides detailed remediation hints and confidence scoring to help developers fix issues."
      ],
      "whenToUse": [
        "Primary Use Case: verifying code safety before deployment or during code review.",
        "Secondary Use Cases:",
        "Auditing legacy code for known vulnerability patterns.",
        "Ensuring AI-generated code does not introduce security flaws.",
        "Checking for hardcoded secrets (API keys, passwords).",
        "Not Suitable For:"
      ],
      "notSuitableFor": [],
      "signature": "async def security_scan(\n    code: str,\n    file_path: Optional[str] = None,\n    # Implicit tier config injected\n    **kwargs\n) -> SecurityResult",
      "toolVersion": "",
      "lastUpdated": "",
      "deepDiveFile": "SECURITY_SCAN_DEEP_DIVE.md",
      "deepDiveUrl": "https://github.com/tescolopio/code-scalpel/blob/main/docs/tools/deep_dive/SECURITY_SCAN_DEEP_DIVE.md"
    },
    {
      "name": "simulate_refactor",
      "status": "\u2705 Stable",
      "tierAvailability": "All (Comm/Pro/Ent)",
      "keyCapabilities": [
        "Pre-flight Safety Check",
        "AST Diffing",
        "Security Regression Test"
      ],
      "purpose": "The simulate_refactor tool is Code Scalpel's pre-flight safety validator for code modifications. Before any AI-generated or human-authored code change is applied to a production codebase, this tool performs a comprehensive \"dry run\" analysis to detect security regressions, breaking changes, and behavioral inconsistencies. It compares original_code against new_code (or applies a unified diff patch) and returns a safety verdict with detailed findings. This prevents the \"LLM Refactoring Accident\" problem where syntactically correct but semantically dangerous code is merged without review.",
      "keyBenefits": [
        "Safety Gate: Prevents introduction of SQL injection, XSS, and other vulnerabilities during refactoring.",
        "Structural Awareness: Detects function signature changes, removed methods, and renamed classes that break APIs.",
        "Multi-Format Input: Accepts direct code strings or unified diff patches for flexibility.",
        "Tiered Intelligence: Community users get essential safety checks; Enterprise users get compliance impact analysis and automated rollback strategies.",
        "Zero Execution: Analyzes code statically without running potentially malicious logic."
      ],
      "whenToUse": [
        "Primary Use Case: Validating AI-generated code refactorings before applying via update_symbol.",
        "Secondary Use Cases:",
        "Pre-commit hooks to verify developer changes.",
        "CI/CD integration as a quality gate.",
        "Interactive refactoring assistance in IDEs.",
        "Code review automation (flag risky changes)."
      ],
      "notSuitableFor": [],
      "signature": "async def simulate_refactor(\n    original_code: str,\n    new_code: Optional[str] = None,\n    patch: Optional[str] = None,\n    strict_mode: bool = False,\n    # Implicit tier config injected\n    **kwargs\n) -> RefactorSimulationResult",
      "toolVersion": "",
      "lastUpdated": "",
      "deepDiveFile": "SIMULATE_REFACTOR_DEEP_DIVE.md",
      "deepDiveUrl": "https://github.com/tescolopio/code-scalpel/blob/main/docs/tools/deep_dive/SIMULATE_REFACTOR_DEEP_DIVE.md"
    },
    {
      "name": "symbolic_execute",
      "status": "\u2705 Stable",
      "tierAvailability": "All (Comm/Pro/Ent)",
      "keyCapabilities": [
        "Mathematical Verification (Z3)",
        "Edge Case Discovery",
        "Path Constraint Solving"
      ],
      "purpose": "The symbolic_execute tool performs formal verification and path exploration by treating program variables as mathematical symbols rather than concrete values. Powered by the Z3 Theorem Prover, it mathematically solves for input values that trigger specific code paths (e.g., \"Find an input x where x > 10 and x % 2 == 0\"). It is the foundational engine behind the generate_unit_tests tool, enabling the creation of mathematically exhaustive test suites with zero hallucination.",
      "keyBenefits": [
        "Mathematical Certainty: Uses SMT (Satisfiability Modulo Theories) to prove code reachability or impossibility.",
        "Corner Case Discovery: Automatically finds edge cases (e.g., Integer Overflow, Division by Zero) that humans often miss.",
        "Zero Hallucination: Path constraints are solved by Z3, ensuring generated inputs actually execute the target code.",
        "Tier-Based Scaling: From basic function analysis (Community) to deep, complex system verification (Enterprise).",
        "Polyglot Foundation: Currently optimized for Python, with a language-agnostic IR (Intermediate Representation) designed for future JS/Java support."
      ],
      "whenToUse": [
        "Primary Use Case: Determining how to reach a specific line of code (e.g., \"What input causes this error?\").",
        "Secondary Use Cases:",
        "Proving code is dead/unreachable.",
        "Generating inputs for regression testing.",
        "Verifying critical business logic (e.g., financial calculations).",
        "Not Suitable For:"
      ],
      "notSuitableFor": [],
      "signature": "",
      "toolVersion": "",
      "lastUpdated": "",
      "deepDiveFile": "SYMBOLIC_EXECUTE_DEEP_DIVE.md",
      "deepDiveUrl": "https://github.com/tescolopio/code-scalpel/blob/main/docs/tools/deep_dive/SYMBOLIC_EXECUTE_DEEP_DIVE.md"
    },
    {
      "name": "type_evaporation_scan",
      "status": "\u2705 Stable",
      "tierAvailability": "All (Comm/Pro/Ent)",
      "keyCapabilities": [
        "Full-Stack Type Safety",
        "Frontend/Backend Correlation",
        "Zod Schema Gen (Ent)"
      ],
      "purpose": "The type_evaporation_scan tool addresses a critical security blind spot in modern full-stack development: Type System Evaporation. This occurs when compile-time static types (like TypeScript interfaces) \"evaporate\" at runtime boundaries (serialization, API calls), leaving the application vulnerable to type confusion attacks and runtime errors. By analyzing both frontend (TypeScript) and backend (Python) code simultaneously, this tool correlates data flows to detect where trusted types are not validated at runtime.",
      "keyBenefits": [
        "Full-Stack Visibility: Analyzes frontend and backend code together to find cross-boundary mismatches.",
        "Ninja Warrior Proven: Developed as a key capability for the \"Ninja Warrior\" security challenge, detecting subtle type confusion vulnerabilities.",
        "Automated Remediation (Enterprise): Auto-generates runtime validation schemas (Zod, Pydantic) to bridge the gap between static types and runtime data.",
        "Tier-Based Scaling: From basic any detection (Community) to enterprise-grade API contract enforcement."
      ],
      "whenToUse": [
        "Primary Use Case: Auditing full-stack applications for \"Type Confusion\" vulnerabilities where API inputs are trusted but not validated.",
        "Secondary Use Cases:",
        "Generating Zod/Pydantic schemas from existing code.",
        "Enforcing API contracts between frontend and backend teams.",
        "Detecting usage of any or safe-but-unsound type assertions (e.g., as User)."
      ],
      "notSuitableFor": [],
      "signature": "",
      "toolVersion": "",
      "lastUpdated": "",
      "deepDiveFile": "TYPE_EVAPORATION_SCAN_DEEP_DIVE.md",
      "deepDiveUrl": "https://github.com/tescolopio/code-scalpel/blob/main/docs/tools/deep_dive/TYPE_EVAPORATION_SCAN_DEEP_DIVE.md"
    },
    {
      "name": "unified_sink_detect",
      "status": "\u2705 Stable",
      "tierAvailability": "All (Comm/Pro/Ent)",
      "keyCapabilities": [
        "Polyglot Sink Detection",
        "CWE Mapping",
        "Confidence Scoring"
      ],
      "purpose": "",
      "keyBenefits": [],
      "whenToUse": [],
      "notSuitableFor": [],
      "signature": "",
      "toolVersion": "",
      "lastUpdated": "",
      "deepDiveFile": "UNIFIED_SINK_DETECT_DEEP_DIVE.md",
      "deepDiveUrl": "https://github.com/tescolopio/code-scalpel/blob/main/docs/tools/deep_dive/UNIFIED_SINK_DETECT_DEEP_DIVE.md"
    },
    {
      "name": "update_symbol",
      "status": "\u2705 Stable",
      "tierAvailability": "All (Comm/Pro/Ent)",
      "keyCapabilities": [
        "Surgical Replacement",
        "Syntax Validation",
        "Atomic Writes & Backups"
      ],
      "purpose": "The update_symbol MCP tool performs surgical code modification by replacing specific functions, classes, or methods with new code while preserving the surrounding file context. Unlike whole-file rewrites (which risk context overflow and unintentional deletions), update_symbol locates the exact boundaries of the target symbol (including decorators and docstrings) and performs an atomic replacement. This is the primary write tool for Code Scalpel, designed to allow AI agents to safely apply fixes and refactoring.",
      "keyBenefits": [
        "Surgical Precision: Modify 1 function in a 5,000-line file without touching the rest",
        "Safety First: Automatic syntax validation before writing to disk",
        "Crash Recovery: Atomic write operations prevent file corruption",
        "Automatic Backups: Creates .bak files by default (rollback safety)",
        "Decorator Awareness: correctly handles decorators as part of the symbol",
        "Indentation Handling: Automatically adjusts indentation of the new code to match the file"
      ],
      "whenToUse": [
        "Primary Use Case: Applying a generated fix to a single function or class",
        "Secondary Use Cases:",
        "Adding a new method to an existing class",
        "Updating docstrings or type hints",
        "Standardizing function signatures",
        "Not Suitable For:"
      ],
      "notSuitableFor": [],
      "signature": "",
      "toolVersion": "",
      "lastUpdated": "",
      "deepDiveFile": "UPDATE_SYMBOL_DEEP_DIVE.md",
      "deepDiveUrl": "https://github.com/tescolopio/code-scalpel/blob/main/docs/tools/deep_dive/UPDATE_SYMBOL_DEEP_DIVE.md"
    },
    {
      "name": "validate_paths",
      "status": "\u2705 Stable",
      "tierAvailability": "All (Comm/Pro/Ent)",
      "keyCapabilities": [
        "Pre-Flight Checks",
        "Docker Awareness",
        "Path Traversal Prevention"
      ],
      "purpose": "The validate_paths tool is the \"Pre-Flight Checklist\" for filesystem operations in the Code Scalpel ecosystem. It validates that file paths are accessible, exist, and are safe to access before more expensive or potentially destructive operations (like extraction or modification) are attempted.",
      "keyBenefits": [
        "Fail Fast: Prevents AI agents from burning tokens on operations destined to fail due to missing files.",
        "Docker Intelligence: Detects execution context and provides volume mount suggestions for inaccessible paths.",
        "Security Enforcement: Validates paths against workspace boundaries to prevent directory traversal attacks (Enterprise).",
        "Batch Efficiency: Validates hundreds of paths in a single tool call (vs. 100 calls to ls or exists).",
        "Tier-Gated Safety: Enforces limits appropriate for usage level (100 paths for Community vs. Unlimited for Pro)."
      ],
      "whenToUse": [],
      "notSuitableFor": [],
      "signature": "",
      "toolVersion": "",
      "lastUpdated": "",
      "deepDiveFile": "VALIDATE_PATHS_DEEP_DIVE.md",
      "deepDiveUrl": "https://github.com/tescolopio/code-scalpel/blob/main/docs/tools/deep_dive/VALIDATE_PATHS_DEEP_DIVE.md"
    },
    {
      "name": "verify_policy_integrity",
      "status": "\u2705 Stable",
      "tierAvailability": "Enterprise",
      "keyCapabilities": [
        "Tamper Detection",
        "Checksum Verification",
        "Signature Validation"
      ],
      "purpose": "The verify_policy_integrity tool is the cryptographic guardian of the Code Scalpel governance model. It ensures that critical policy definitions (allowlists, denylists, compliance rules) have not been tampered with by unauthorized actors, malicious insiders, or compromised processes. By enforcing a FAIL-CLOSED security model, it prevents the system from operating under a compromised configuration.",
      "keyBenefits": [
        "Immutable Governance: Cryptographically guarantees that the running policy matches the approved/signed policy.",
        "Fail-Closed Security: Any anomaly (missing stamp, hash mismatch, invalid signature) causes an immediate denial of operations.",
        "Bypass Resistance: Defeats chmod +w attacks\u2014even if file permissions are overridden, the cryptographic content verification will still fail.",
        "Multi-Source Manifests: Supports verification against local files, environment variables (CI/CD friendly), or git history constraints."
      ],
      "whenToUse": [
        "Primary Use Case: Pre-flight check before continuously running AI agents with modification capabilities (e.g., update_symbol).",
        "Secondary Use Cases:",
        "Auditing production environments for \"Policy Drift\".",
        "Verifying integrity of compliance artifacts in CI/CD pipelines.",
        "Detecting unauthorized manual edits to policy.yaml."
      ],
      "notSuitableFor": [],
      "signature": "",
      "toolVersion": "",
      "lastUpdated": "",
      "deepDiveFile": "VERIFY_POLICY_INTEGRITY_DEEP_DIVE.md",
      "deepDiveUrl": "https://github.com/tescolopio/code-scalpel/blob/main/docs/tools/deep_dive/VERIFY_POLICY_INTEGRITY_DEEP_DIVE.md"
    }
  ]
}
