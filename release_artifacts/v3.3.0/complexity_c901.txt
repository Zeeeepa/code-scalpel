C901 `_parse_code` is too complex (13 > 10)
   --> src/code_scalpel/analysis/code_analyzer.py:427:9
    |
425 |         return "python"
426 |
427 |     def _parse_code(
    |         ^^^^^^^^^^^
428 |         self,
429 |         code: str,
    |

C901 `_compute_metrics` is too complex (12 > 10)
   --> src/code_scalpel/analysis/code_analyzer.py:559:9
    |
557 |         return result
558 |
559 |     def _compute_metrics(
    |         ^^^^^^^^^^^^^^^^
560 |         self,
561 |         tree: Optional[ast.AST],
    |

C901 `_collect_definitions` is too complex (11 > 10)
   --> src/code_scalpel/analysis/code_analyzer.py:765:9
    |
763 |         return dead_code
764 |
765 |     def _collect_definitions(self, tree: ast.AST) -> dict[str, Any]:
    |         ^^^^^^^^^^^^^^^^^^^^
766 |         """Collect all definitions in the code."""
767 |         definitions = {"functions": {}, "classes": {}, "variables": {}, "imports": {}}
    |

C901 `_remove_unused_imports` is too complex (13 > 10)
    --> src/code_scalpel/analysis/code_analyzer.py:1113:9
     |
1111 |         return "\n".join(lines)
1112 |
1113 |     def _remove_unused_imports(self, code: str, tree: ast.AST) -> str:
     |         ^^^^^^^^^^^^^^^^^^^^^^
1114 |         """Remove unused import statements."""
1115 |         uses = self._collect_uses(tree)
     |

C901 `_scan_python_deps` is too complex (13 > 10)
   --> src/code_scalpel/analysis/cross_repo.py:111:9
    |
109 |         return deps
110 |
111 |     def _scan_python_deps(
    |         ^^^^^^^^^^^^^^^^^
112 |         self,
113 |         repo_path: Path,
    |

C901 `_find_internal_imports` is too complex (11 > 10)
   --> src/code_scalpel/analysis/cross_repo.py:356:9
    |
354 |         return conflicts
355 |
356 |     def _find_internal_imports(
    |         ^^^^^^^^^^^^^^^^^^^^^^
357 |         self,
358 |         repo_path: Path,
    |

C901 `collect` is too complex (12 > 10)
   --> src/code_scalpel/analysis/custom_metrics.py:437:9
    |
435 |         self._custom_fns[name] = (fn, unit)
436 |
437 |     def collect(
    |         ^^^^^^^
438 |         self,
439 |         project_path: str | Path,
    |

C901 `detect` is too complex (13 > 10)
   --> src/code_scalpel/analysis/generated_code.py:109:9
    |
107 |         self.root = Path(project_root)
108 |
109 |     def detect(
    |         ^^^^^^
110 |         self, check_headers: bool = True, max_files: int = 10000
111 |     ) -> GeneratedCodeResult:
    |

C901 `_detect_nx` is too complex (12 > 10)
  --> src/code_scalpel/analysis/monorepo.py:90:9
   |
88 |         )
89 |
90 |     def _detect_nx(self) -> Optional[MonorepoDetectionResult]:
   |         ^^^^^^^^^^
91 |         """Detect Nx monorepo."""
92 |         nx_json = self.root / "nx.json"
   |

C901 `discover_files` is too complex (19 > 10)
   --> src/code_scalpel/analysis/parallel_crawler.py:165:9
    |
163 |         self._errors: List[str] = []
164 |
165 |     def discover_files(
    |         ^^^^^^^^^^^^^^
166 |         self,
167 |         extensions: Optional[Set[str]] = None,
    |

C901 `crawl` is too complex (23 > 10)
   --> src/code_scalpel/analysis/project_crawler.py:802:9
    |
800 |         return False
801 |
802 |     def crawl(self) -> CrawlResult:
    |         ^^^^^
803 |         """
804 |         Crawl the project and analyze all Python files.
    |

C901 `_analyze_file` is too complex (13 > 10)
   --> src/code_scalpel/analysis/project_crawler.py:922:9
    |
920 |         return result
921 |
922 |     def _analyze_file(self, file_path: str) -> FileAnalysisResult:
    |         ^^^^^^^^^^^^^
923 |         """
924 |         Analyze a single Python file.
    |

C901 `detect_project_type` is too complex (14 > 10)
   --> src/code_scalpel/analysis/smart_crawl.py:100:9
    |
 98 |         self._project_type: Optional[ProjectTypeInfo] = None
 99 |
100 |     def detect_project_type(self) -> ProjectTypeInfo:
    |         ^^^^^^^^^^^^^^^^^^^
101 |         """Detect the project type based on marker files."""
102 |         if self._project_type is not None:
    |

C901 `_analyze_definitions_js_ts` is too complex (52 > 10)
   --> src/code_scalpel/ast_tools/call_graph.py:313:9
    |
311 |                     yield Path(root) / file
312 |
313 |     def _analyze_definitions_js_ts(self, file_path: Path, rel_path: str) -> None:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^
314 |         """Extract JS/TS definitions and import/export metadata.
    |

C901 `_analyze_calls_js_ts` is too complex (59 > 10)
   --> src/code_scalpel/ast_tools/call_graph.py:530:9
    |
528 |         return None
529 |
530 |     def _analyze_calls_js_ts(
    |         ^^^^^^^^^^^^^^^^^^^^
531 |         self,
532 |         file_path: Path,
    |

C901 `_resolve_callee` is too complex (11 > 10)
   --> src/code_scalpel/ast_tools/call_graph.py:564:13
    |
562 |             root = None
563 |
564 |         def _resolve_callee(raw_callee: str, caller_parent: str | None) -> str:
    |             ^^^^^^^^^^^^^^^
565 |             # Resolve this.method() to Class.method when inside a class method.
566 |             if advanced_resolution and caller_parent and raw_callee.startswith("this."):
    |

C901 `_callee_from_call` is too complex (11 > 10)
   --> src/code_scalpel/ast_tools/call_graph.py:622:17
    |
620 |                 return (best[2], best[3])
621 |
622 |             def _callee_from_call(node) -> str | None:
    |                 ^^^^^^^^^^^^^^^^^
623 |                 # call_expression: function field
624 |                 fn = node.child_by_field("function")
    |

C901 `_analyze_calls` is too complex (37 > 10)
   --> src/code_scalpel/ast_tools/call_graph.py:887:9
    |
885 |                     self.imports[rel_path][asname] = full_name
886 |
887 |     def _analyze_calls(
    |         ^^^^^^^^^^^^^^
888 |         self,
889 |         tree: ast.AST,
    |

C901 `build_with_details` is too complex (64 > 10)
    --> src/code_scalpel/ast_tools/call_graph.py:1092:9
     |
1090 |     # [20251213_FEATURE] v1.5.0 - Enhanced call graph methods
1091 |
1092 |     def build_with_details(
     |         ^^^^^^^^^^^^^^^^^^
1093 |         self,
1094 |         entry_point: Optional[str] = None,
     |

C901 `_add_js_nodes_esprima` is too complex (27 > 10)
    --> src/code_scalpel/ast_tools/call_graph.py:1209:13
     |
1207 |             tree_sitter_available = False
1208 |
1209 |         def _add_js_nodes_esprima(file_path: Path, rel_path: str) -> None:
     |             ^^^^^^^^^^^^^^^^^^^^^
1210 |             try:
1211 |                 import esprima  # type: ignore[import-untyped]
     |

C901 `_is_entry_point` is too complex (21 > 10)
    --> src/code_scalpel/ast_tools/call_graph.py:1425:9
     |
1423 |         )
1424 |
1425 |     def _is_entry_point(
     |         ^^^^^^^^^^^^^^^
1426 |         self, func_node: ast.FunctionDef | ast.AsyncFunctionDef, tree: ast.AST
1427 |     ) -> bool:
     |

C901 `detect_circular_imports` is too complex (21 > 10)
    --> src/code_scalpel/ast_tools/call_graph.py:1690:9
     |
1688 |         return "\n".join(lines)
1689 |
1690 |     def detect_circular_imports(self) -> List[List[str]]:
     |         ^^^^^^^^^^^^^^^^^^^^^^^
1691 |         """
1692 |         Detect circular import cycles in the project.
     |

C901 `_gather_dependencies` is too complex (14 > 10)
   --> src/code_scalpel/ast_tools/cross_file_extractor.py:784:9
    |
782 |         return set(dir(builtins))
783 |
784 |     def _gather_dependencies(
    |         ^^^^^^^^^^^^^^^^^^^^
785 |         self,
786 |         target: ExtractedSymbol,
    |

C901 `_generate_combined_code` is too complex (15 > 10)
   --> src/code_scalpel/ast_tools/cross_file_extractor.py:927:9
    |
925 |         return root in stdlib_prefixes
926 |
927 |     def _generate_combined_code(self, result: ExtractionResult) -> None:
    |         ^^^^^^^^^^^^^^^^^^^^^^^
928 |         """
929 |         Generate the combined code output with dependencies first.
    |

C901 `_parse_python_deps` is too complex (12 > 10)
  --> src/code_scalpel/ast_tools/dependency_parser.py:79:9
   |
77 |         return {k: v for k, v in deps.items() if v}
78 |
79 |     def _parse_python_deps(self) -> List[Dict[str, str]]:
   |         ^^^^^^^^^^^^^^^^^^
80 |         deps = []
   |

C901 `_parse_maven_deps` is too complex (14 > 10)
   --> src/code_scalpel/ast_tools/dependency_parser.py:139:9
    |
137 |         return deps
138 |
139 |     def _parse_maven_deps(self) -> List[Dict[str, str]]:
    |         ^^^^^^^^^^^^^^^^^
140 |         deps: List[Dict[str, str]] = []
    |

C901 `_extract_imports` is too complex (12 > 10)
   --> src/code_scalpel/ast_tools/import_resolver.py:584:9
    |
582 |                     self._incremental.record_dependency(source_path, target_path)
583 |
584 |     def _extract_imports(
    |         ^^^^^^^^^^^^^^^^
585 |         self, tree: ast.Module, module_name: str, file_path: str
586 |     ) -> None:
    |

C901 `_extract_framework_imports` is too complex (13 > 10)
   --> src/code_scalpel/ast_tools/import_resolver.py:669:9
    |
668 |     # [20251214_FEATURE] Django/Flask framework import extraction
669 |     def _extract_framework_imports(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^
670 |         self, tree: ast.Module, module_name: str, file_path: str
671 |     ) -> None:
    |

C901 `resolve_symbol` is too complex (12 > 10)
    --> src/code_scalpel/ast_tools/import_resolver.py:1001:9
     |
 999 |         return self._circular_imports.copy()
1000 |
1001 |     def resolve_symbol(
     |         ^^^^^^^^^^^^^^
1002 |         self, from_module: str, symbol_name: str
1003 |     ) -> Tuple[Optional[str], Optional[SymbolDefinition]]:
     |

C901 `topological_sort` is too complex (11 > 10)
    --> src/code_scalpel/ast_tools/import_resolver.py:1081:9
     |
1079 |         return self.edges.get(module_name, set()).copy()
1080 |
1081 |     def topological_sort(self) -> List[str]:
     |         ^^^^^^^^^^^^^^^^
1082 |         """
1083 |         Return modules in topological order (dependencies first).
     |

C901 `_generate_mutations` is too complex (15 > 10)
   --> src/code_scalpel/autonomy/mutation_gate.py:420:9
    |
418 |         )
419 |
420 |     def _generate_mutations(self, code: str, language: str) -> List[Mutation]:
    |         ^^^^^^^^^^^^^^^^^^^
421 |         """
422 |         Generate additional mutations for the code.
    |

C901 `analyze_code` is too complex (13 > 10)
   --> src/code_scalpel/cli.py:197:5
    |
197 | def analyze_code(
    |     ^^^^^^^^^^^^
198 |     code: str,
199 |     output_format: str = "text",
    |

C901 `init_configuration` is too complex (11 > 10)
   --> src/code_scalpel/cli.py:409:5
    |
409 | def init_configuration(target_dir: str = ".", force: bool = False) -> int:
    |     ^^^^^^^^^^^^^^^^^^
410 |     """Initialize .code-scalpel configuration directory.
    |

C901 `start_mcp_server` is too complex (14 > 10)
   --> src/code_scalpel/cli.py:510:5
    |
510 | def start_mcp_server(
    |     ^^^^^^^^^^^^^^^^
511 |     transport: str = "stdio",
512 |     host: str = "127.0.0.1",
    |

C901 `main` is too complex (23 > 10)
   --> src/code_scalpel/cli.py:796:5
    |
796 | def main() -> int:
    |     ^^^^
797 |     """Main CLI entry point."""
798 |     from . import __version__
    |

C901 `_traverse_ast` is too complex (14 > 10)
   --> src/code_scalpel/code_parsers/adapters/javascript_adapter.py:265:9
    |
263 |         self._traverse_ast(ast)
264 |
265 |     def _traverse_ast(self, node: Any, depth: int = 0) -> None:
    |         ^^^^^^^^^^^^^
266 |         """Recursively traverse AST to find functions and classes."""
267 |         if node is None or depth > 100:  # Prevent infinite recursion
    |

C901 `_extract_from_ir` is too complex (16 > 10)
   --> src/code_scalpel/code_parsers/extractor.py:416:9
    |
414 |             )
415 |
416 |     def _extract_from_ir(
    |         ^^^^^^^^^^^^^^^^
417 |         self, target_type: str, target_name: str
418 |     ) -> PolyglotExtractionResult:
    |

C901 `_extract_parameters` is too complex (12 > 10)
   --> src/code_scalpel/code_parsers/java_parsers/java_parser_treesitter.py:474:9
    |
472 |         return complexity, lambda_count, method_ref_count
473 |
474 |     def _extract_parameters(self, node) -> list[JavaParameter]:
    |         ^^^^^^^^^^^^^^^^^^^
475 |         """Extract method parameters."""
476 |         parameters = []
    |

C901 `_extract_class` is too complex (15 > 10)
   --> src/code_scalpel/code_parsers/java_parsers/java_parser_treesitter.py:699:9
    |
697 |         )
698 |
699 |     def _extract_class(self, node, is_inner: bool = False) -> JavaClass:
    |         ^^^^^^^^^^^^^^
700 |         """Extract class information from a class declaration node."""
701 |         name_node = node.child_by_field_name("name")
    |

C901 `_extract_record` is too complex (12 > 10)
   --> src/code_scalpel/code_parsers/java_parsers/java_parser_treesitter.py:770:9
    |
768 |         return java_class
769 |
770 |     def _extract_record(self, node) -> JavaRecord:
    |         ^^^^^^^^^^^^^^^
771 |         """Extract record information from a record declaration node (Java 14+)."""
772 |         name_node = node.child_by_field_name("name")
    |

C901 `_extract_module_directive` is too complex (23 > 10)
   --> src/code_scalpel/code_parsers/java_parsers/java_parser_treesitter.py:872:9
    |
870 |         )
871 |
872 |     def _extract_module_directive(self, node) -> Optional[JavaModuleDirective]:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^
873 |         """Extract a single module directive."""
874 |         directive_type = None
    |

C901 `parse_detailed` is too complex (14 > 10)
    --> src/code_scalpel/code_parsers/java_parsers/java_parser_treesitter.py:1036:9
     |
1034 |         return result
1035 |
1036 |     def parse_detailed(self, code: str) -> JavaParseResult:
     |         ^^^^^^^^^^^^^^
1037 |         """
1038 |         Parse Java source code and return detailed structural information.
     |

C901 `get_metrics` is too complex (12 > 10)
   --> src/code_scalpel/code_parsers/java_parsers/java_parsers_SonarQube.py:170:9
    |
168 |         return issues
169 |
170 |     def get_metrics(self, project_key: str) -> SonarMetrics:
    |         ^^^^^^^^^^^
171 |         """
172 |         Get project metrics.
    |

C901 `_cognitive_complexity_recursive` is too complex (11 > 10)
   --> src/code_scalpel/code_parsers/java_parsers/java_parsers_javalang.py:564:9
    |
562 |         return self._cognitive_complexity_recursive(node, nesting=0)
563 |
564 |     def _cognitive_complexity_recursive(self, node: JavaNode, nesting: int) -> int:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
565 |         """
566 |         Recursively calculate cognitive complexity.
    |

C901 `_collect_halstead_tokens` is too complex (26 > 10)
   --> src/code_scalpel/code_parsers/java_parsers/java_parsers_javalang.py:645:9
    |
643 |         )
644 |
645 |     def _collect_halstead_tokens(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^
646 |         self, node: JavaNode, operators: dict[str, int], operands: dict[str, int]
647 |     ) -> None:
    |

C901 `_check_singleton_pattern` is too complex (16 > 10)
   --> src/code_scalpel/code_parsers/java_parsers/java_parsers_javalang.py:877:9
    |
875 |         return patterns
876 |
877 |     def _check_singleton_pattern(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^
878 |         self, class_node: JavaNode
879 |     ) -> Optional[DesignPatternMatch]:
    |

C901 `_extract_try_catch_patterns` is too complex (16 > 10)
    --> src/code_scalpel/code_parsers/java_parsers/java_parsers_javalang.py:1431:9
     |
1429 |     # ==================== TRY-CATCH PATTERN EXTRACTION ====================
1430 |
1431 |     def _extract_try_catch_patterns(
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^
1432 |         self, ast: JavaCompilationUnit
1433 |     ) -> list[TryCatchPattern]:
     |

C901 `_calculate_cognitive_recursive` is too complex (12 > 10)
   --> src/code_scalpel/code_parsers/javascript_parsers/javascript_parsers_esprima.py:573:9
    |
571 |         return self._calculate_cognitive_recursive(node, 0)
572 |
573 |     def _calculate_cognitive_recursive(self, node: JSNode, nesting: int) -> int:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
574 |         """Recursive helper for cognitive complexity calculation."""
575 |         complexity = 0
    |

C901 `_collect_halstead` is too complex (22 > 10)
   --> src/code_scalpel/code_parsers/javascript_parsers/javascript_parsers_esprima.py:658:9
    |
656 |         )
657 |
658 |     def _collect_halstead(
    |         ^^^^^^^^^^^^^^^^^
659 |         self, node: JSNode, operators: dict[str, int], operands: dict[str, int]
660 |     ) -> None:
    |

C901 `detect_security_issues` is too complex (26 > 10)
   --> src/code_scalpel/code_parsers/javascript_parsers/javascript_parsers_esprima.py:788:9
    |
786 |         )
787 |
788 |     def detect_security_issues(
    |         ^^^^^^^^^^^^^^^^^^^^^^
789 |         self, ast: JSNode, code: str = ""
790 |     ) -> list[SecurityIssue]:
    |

C901 `visit` is too complex (25 > 10)
   --> src/code_scalpel/code_parsers/javascript_parsers/javascript_parsers_esprima.py:800:13
    |
798 |         issues: list[SecurityIssue] = []
799 |
800 |         def visit(node: JSNode) -> None:
    |             ^^^^^
801 |             # Check for eval
802 |             if isinstance(node, esprima.nodes.CallExpression):
    |

C901 `extract_functions` is too complex (20 > 10)
   --> src/code_scalpel/code_parsers/javascript_parsers/javascript_parsers_esprima.py:973:9
    |
971 |         return issues
972 |
973 |     def extract_functions(self, ast: JSNode) -> list[FunctionInfo]:
    |         ^^^^^^^^^^^^^^^^^
974 |         """
975 |         Extract all functions from the AST.
    |

C901 `visit` is too complex (19 > 10)
   --> src/code_scalpel/code_parsers/javascript_parsers/javascript_parsers_esprima.py:982:13
    |
980 |         functions: list[FunctionInfo] = []
981 |
982 |         def visit(node: JSNode, depth: int = 0) -> None:
    |             ^^^^^
983 |             if isinstance(
984 |                 node,
    |

C901 `extract_imports` is too complex (12 > 10)
    --> src/code_scalpel/code_parsers/javascript_parsers/javascript_parsers_esprima.py:1095:9
     |
1093 |         return functions
1094 |
1095 |     def extract_imports(self, ast: JSNode) -> list[ImportInfo]:
     |         ^^^^^^^^^^^^^^^
1096 |         """
1097 |         Extract ES6 module imports from AST.
     |

C901 `visit` is too complex (11 > 10)
    --> src/code_scalpel/code_parsers/javascript_parsers/javascript_parsers_esprima.py:1104:13
     |
1102 |         imports: list[ImportInfo] = []
1103 |
1104 |         def visit(node: JSNode) -> None:
     |             ^^^^^
1105 |             if isinstance(node, esprima.nodes.ImportDeclaration):
1106 |                 module = (
     |

C901 `extract_exports` is too complex (16 > 10)
    --> src/code_scalpel/code_parsers/javascript_parsers/javascript_parsers_esprima.py:1147:9
     |
1145 |         return imports
1146 |
1147 |     def extract_exports(self, ast: JSNode) -> list[ExportInfo]:
     |         ^^^^^^^^^^^^^^^
1148 |         """
1149 |         Extract ES6 module exports from AST.
     |

C901 `visit` is too complex (15 > 10)
    --> src/code_scalpel/code_parsers/javascript_parsers/javascript_parsers_esprima.py:1156:13
     |
1154 |         exports: list[ExportInfo] = []
1155 |
1156 |         def visit(node: JSNode) -> None:
     |             ^^^^^
1157 |             if isinstance(node, esprima.nodes.ExportDefaultDeclaration):
1158 |                 name = "<default>"
     |

C901 `_determine_type_kind` is too complex (15 > 10)
   --> src/code_scalpel/code_parsers/javascript_parsers/javascript_parsers_flow.py:457:9
    |
455 |         return params
456 |
457 |     def _determine_type_kind(self, type_value: str) -> FlowTypeKind:
    |         ^^^^^^^^^^^^^^^^^^^^
458 |         """Determine the kind of a Flow type."""
459 |         type_value = type_value.strip()
    |

C901 `parse_config` is too complex (15 > 10)
   --> src/code_scalpel/code_parsers/javascript_parsers/javascript_parsers_flow.py:610:9
    |
608 |             raise TimeoutError("Flow coverage timed out")
609 |
610 |     def parse_config(self, config_path: str = ".flowconfig") -> FlowConfig:
    |         ^^^^^^^^^^^^
611 |         """
612 |         Parse a .flowconfig file.
    |

C901 `_extract_symbols` is too complex (17 > 10)
   --> src/code_scalpel/code_parsers/javascript_parsers/javascript_parsers_treesitter.py:466:9
    |
464 |         return errors
465 |
466 |     def _extract_symbols(self, root: TreeSitterNode) -> list[JSSymbol]:
    |         ^^^^^^^^^^^^^^^^
467 |         """Extract all symbols from the tree."""
468 |         symbols: list[JSSymbol] = []
    |

C901 `visit` is too complex (16 > 10)
   --> src/code_scalpel/code_parsers/javascript_parsers/javascript_parsers_treesitter.py:471:13
    |
469 |         current_class: Optional[str] = None
470 |
471 |         def visit(
    |             ^^^^^
472 |             node: TreeSitterNode, is_exported: bool = False, is_default: bool = False
473 |         ) -> None:
    |

C901 `_extract_imports` is too complex (19 > 10)
   --> src/code_scalpel/code_parsers/javascript_parsers/javascript_parsers_treesitter.py:668:9
    |
666 |         return params
667 |
668 |     def _extract_imports(self, root: TreeSitterNode) -> list[ImportStatement]:
    |         ^^^^^^^^^^^^^^^^
669 |         """Extract all import statements."""
670 |         imports: list[ImportStatement] = []
    |

C901 `visit` is too complex (18 > 10)
   --> src/code_scalpel/code_parsers/javascript_parsers/javascript_parsers_treesitter.py:672:13
    |
670 |         imports: list[ImportStatement] = []
671 |
672 |         def visit(node: TreeSitterNode) -> None:
    |             ^^^^^
673 |             if node.type == "import_statement":
674 |                 source = node.child_by_field("source")
    |

C901 `_extract_exports` is too complex (12 > 10)
   --> src/code_scalpel/code_parsers/javascript_parsers/javascript_parsers_treesitter.py:732:9
    |
730 |         return imports
731 |
732 |     def _extract_exports(self, root: TreeSitterNode) -> list[ExportStatement]:
    |         ^^^^^^^^^^^^^^^^
733 |         """Extract all export statements."""
734 |         exports: list[ExportStatement] = []
    |

C901 `visit` is too complex (11 > 10)
   --> src/code_scalpel/code_parsers/javascript_parsers/javascript_parsers_treesitter.py:736:13
    |
734 |         exports: list[ExportStatement] = []
735 |
736 |         def visit(node: TreeSitterNode) -> None:
    |             ^^^^^
737 |             if node.type == "export_statement":
738 |                 is_default = any(c.type == "default" for c in node.children)
    |

C901 `_extract_jsx_components` is too complex (20 > 10)
   --> src/code_scalpel/code_parsers/javascript_parsers/javascript_parsers_treesitter.py:789:9
    |
787 |         return exports
788 |
789 |     def _extract_jsx_components(self, root: TreeSitterNode) -> list[JSXComponent]:
    |         ^^^^^^^^^^^^^^^^^^^^^^^
790 |         """Extract JSX/TSX component usages."""
791 |         components: list[JSXComponent] = []
    |

C901 `visit` is too complex (19 > 10)
   --> src/code_scalpel/code_parsers/javascript_parsers/javascript_parsers_treesitter.py:793:13
    |
791 |         components: list[JSXComponent] = []
792 |
793 |         def visit(node: TreeSitterNode) -> None:
    |             ^^^^^
794 |             if node.type in ("jsx_element", "jsx_self_closing_element"):
795 |                 is_self_closing = node.type == "jsx_self_closing_element"
    |

C901 `_determine_type_kind` is too complex (13 > 10)
   --> src/code_scalpel/code_parsers/javascript_parsers/javascript_parsers_typescript.py:677:9
    |
675 |         return params
676 |
677 |     def _determine_type_kind(self, type_value: str) -> TypeKind:
    |         ^^^^^^^^^^^^^^^^^^^^
678 |         """Determine the kind of a type from its string representation."""
679 |         type_value = type_value.strip()
    |

C901 `detect_language_confidence` is too complex (14 > 10)
   --> src/code_scalpel/code_parsers/language_detection.py:477:5
    |
477 | def detect_language_confidence(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^
478 |     filepath: Optional[str] = None,
479 |     code: Optional[str] = None,
    |

C901 `__getattr__` is too complex (16 > 10)
   --> src/code_scalpel/code_parsers/python_parsers/__init__.py:365:5
    |
363 | # Lazy Loading Implementation
364 | # =============================================================================
365 | def __getattr__(name: str):
    |     ^^^^^^^^^^^
366 |     """
367 |     Lazy load parser classes on first access.
    |

C901 `extract_type_annotations` is too complex (18 > 10)
    --> src/code_scalpel/code_parsers/python_parsers/python_parsers_ast.py:1602:9
     |
1600 |         return analyzer.analyze()
1601 |
1602 |     def extract_type_annotations(
     |         ^^^^^^^^^^^^^^^^^^^^^^^^
1603 |         self, module: PythonModule
1604 |     ) -> dict[str, TypeAnnotation]:
     |

C901 `visit_ClassDef` is too complex (14 > 10)
    --> src/code_scalpel/code_parsers/python_parsers/python_parsers_ast.py:2007:9
     |
2005 |         self.scope_stack.pop()
2006 |
2007 |     def visit_ClassDef(self, node: ast.ClassDef) -> None:
     |         ^^^^^^^^^^^^^^
2008 |         """Visit a class definition."""
2009 |         bases = [ast.unparse(base) for base in node.bases]
     |

C901 `_visit_stmt` is too complex (16 > 10)
    --> src/code_scalpel/code_parsers/python_parsers/python_parsers_ast.py:2948:9
     |
2946 |         return isinstance(last_stmt, (ast.Return, ast.Raise))
2947 |
2948 |     def _visit_stmt(self, stmt: ast.stmt) -> None:
     |         ^^^^^^^^^^^
2949 |         """Visit a statement and update CFG."""
2950 |         if self.current_block is None:
     |

C901 `_visit_try` is too complex (17 > 10)
    --> src/code_scalpel/code_parsers/python_parsers/python_parsers_ast.py:3124:9
     |
3122 |         self._set_current_block(loop_after)
3123 |
3124 |     def _visit_try(self, stmt: ast.Try) -> None:
     |         ^^^^^^^^^^
3125 |         """Handle try/except/else/finally blocks."""
3126 |         try_block = self._new_block("try_body")
     |

C901 `_process_statement` is too complex (21 > 10)
    --> src/code_scalpel/code_parsers/python_parsers/python_parsers_ast.py:3450:9
     |
3448 |                 self._process_statement(stmt, block)
3449 |
3450 |     def _process_statement(self, stmt: ast.stmt, block: BasicBlock) -> None:
     |         ^^^^^^^^^^^^^^^^^^
3451 |         """Process a statement for definitions and uses."""
3452 |         # First collect uses (before any definitions in this statement)
     |

C901 `_compute_constant_propagation` is too complex (13 > 10)
    --> src/code_scalpel/code_parsers/python_parsers/python_parsers_ast.py:3665:9
     |
3663 |         return undefined
3664 |
3665 |     def _compute_constant_propagation(self) -> dict[int, dict[str, ConstantValue]]:
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
3666 |         """
3667 |         Compute constant propagation using a forward data flow analysis.
     |

C901 `_evaluate_constant` is too complex (19 > 10)
    --> src/code_scalpel/code_parsers/python_parsers/python_parsers_ast.py:3740:9
     |
3738 |                 constants[stmt.target.id] = ConstantValue.not_constant()
3739 |
3740 |     def _evaluate_constant(
     |         ^^^^^^^^^^^^^^^^^^
3741 |         self,
3742 |         node: ast.expr,
     |

C901 `_eval_binop` is too complex (13 > 10)
    --> src/code_scalpel/code_parsers/python_parsers/python_parsers_ast.py:3799:9
     |
3797 |         return ConstantValue.not_constant()
3798 |
3799 |     def _eval_binop(
     |         ^^^^^^^^^^^
3800 |         self, op: ast.operator, left: object, right: object
3801 |     ) -> object | None:
     |

C901 `_compute_available_expressions` is too complex (16 > 10)
    --> src/code_scalpel/code_parsers/python_parsers/python_parsers_ast.py:3849:9
     |
3847 |         return None
3848 |
3849 |     def _compute_available_expressions(self) -> dict[int, set[Expression]]:
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
3850 |         """
3851 |         Compute available expressions using forward data flow analysis.
     |

C901 `_compute_very_busy_expressions` is too complex (16 > 10)
    --> src/code_scalpel/code_parsers/python_parsers/python_parsers_ast.py:3922:9
     |
3920 |         return avail_in
3921 |
3922 |     def _compute_very_busy_expressions(self) -> dict[int, set[Expression]]:
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
3923 |         """
3924 |         Compute very busy expressions using backward data flow analysis.
     |

C901 `analyze` is too complex (15 > 10)
    --> src/code_scalpel/code_parsers/python_parsers/python_parsers_bandit.py:1317:9
     |
1315 |             return False
1316 |
1317 |     def analyze(
     |         ^^^^^^^
1318 |         self,
1319 |         target: str | Path | list[str | Path],
     |

C901 `_detect_smells` is too complex (13 > 10)
   --> src/code_scalpel/code_parsers/python_parsers/python_parsers_code_quality.py:735:9
    |
733 |                 report.classes.append(class_info)
734 |
735 |     def _detect_smells(
    |         ^^^^^^^^^^^^^^
736 |         self,
737 |         tree: ast.AST,
    |

C901 `calculate_cognitive_complexity` is too complex (23 > 10)
    --> src/code_scalpel/code_parsers/python_parsers/python_parsers_code_quality.py:1291:9
     |
1289 |         return complexity
1290 |
1291 |     def calculate_cognitive_complexity(self, node: ast.AST) -> int:
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
1292 |         """
1293 |         Calculate cognitive complexity for an AST node.
     |

C901 `walk` is too complex (22 > 10)
    --> src/code_scalpel/code_parsers/python_parsers/python_parsers_code_quality.py:1306:13
     |
1304 |         complexity = 0
1305 |
1306 |         def walk(n: ast.AST, nesting: int = 0) -> None:
     |             ^^^^
1307 |             nonlocal complexity
     |

C901 `_from_ini` is too complex (11 > 10)
   --> src/code_scalpel/code_parsers/python_parsers/python_parsers_flake8.py:593:9
    |
592 |     @classmethod
593 |     def _from_ini(cls, path: Path) -> Flake8Config:
    |         ^^^^^^^^^
594 |         """Load configuration from INI file (.flake8, setup.cfg, or tox.ini)."""
595 |         parser = configparser.ConfigParser()
    |

C901 `find_config` is too complex (11 > 10)
   --> src/code_scalpel/code_parsers/python_parsers/python_parsers_flake8.py:684:9
    |
683 |     @classmethod
684 |     def find_config(cls, start_path: Path) -> Flake8Config | None:
    |         ^^^^^^^^^^^
685 |         """
686 |         Find and load configuration from the nearest config file.
    |

C901 `analyze_json` is too complex (13 > 10)
    --> src/code_scalpel/code_parsers/python_parsers/python_parsers_flake8.py:1038:9
     |
1036 |         return report
1037 |
1038 |     def analyze_json(
     |         ^^^^^^^^^^^^
1039 |         self,
1040 |         target: str | Path | list[str | Path],
     |

C901 `_from_ini` is too complex (18 > 10)
   --> src/code_scalpel/code_parsers/python_parsers/python_parsers_mypy.py:719:9
    |
718 |     @classmethod
719 |     def _from_ini(cls, path: Path, section: str = "mypy") -> MypyConfig:
    |         ^^^^^^^^^
720 |         """Load configuration from INI file (mypy.ini or setup.cfg)."""
721 |         parser = configparser.ConfigParser()
    |

C901 `_from_dict` is too complex (21 > 10)
   --> src/code_scalpel/code_parsers/python_parsers/python_parsers_mypy.py:792:9
    |
791 |     @classmethod
792 |     def _from_dict(cls, data: dict[str, Any]) -> MypyConfig:
    |         ^^^^^^^^^^
793 |         """Create MypyConfig from a dictionary."""
794 |         config = cls()
    |

C901 `find_config` is too complex (13 > 10)
   --> src/code_scalpel/code_parsers/python_parsers/python_parsers_mypy.py:844:9
    |
843 |     @classmethod
844 |     def find_config(cls, start_path: Path) -> MypyConfig | None:
    |         ^^^^^^^^^^^
845 |         """
846 |         Find and load configuration from the nearest config file.
    |

C901 `to_cli_args` is too complex (12 > 10)
   --> src/code_scalpel/code_parsers/python_parsers/python_parsers_mypy.py:907:9
    |
905 |         return None
906 |
907 |     def to_cli_args(self) -> list[str]:
    |         ^^^^^^^^^^^
908 |         """Convert configuration to CLI arguments."""
909 |         args = []
    |

C901 `analyze` is too complex (13 > 10)
    --> src/code_scalpel/code_parsers/python_parsers/python_parsers_mypy.py:1082:9
     |
1080 |             return False
1081 |
1082 |     def analyze(
     |         ^^^^^^^
1083 |         self,
1084 |         target: str | Path | list[str | Path],
     |

C901 `analyze_json` is too complex (13 > 10)
    --> src/code_scalpel/code_parsers/python_parsers/python_parsers_mypy.py:1174:9
     |
1172 |         return report
1173 |
1174 |     def analyze_json(
     |         ^^^^^^^^^^^^
1175 |         self,
1176 |         target: str | Path | list[str | Path],
     |

C901 `analyze_with_context` is too complex (17 > 10)
    --> src/code_scalpel/code_parsers/python_parsers/python_parsers_mypy.py:1274:9
     |
1272 |         return report
1273 |
1274 |     def analyze_with_context(
     |         ^^^^^^^^^^^^^^^^^^^^
1275 |         self,
1276 |         target: str | Path | list[str | Path],
     |

C901 `_from_dict` is too complex (14 > 10)
   --> src/code_scalpel/code_parsers/python_parsers/python_parsers_prospector.py:359:9
    |
358 |     @classmethod
359 |     def _from_dict(cls, data: dict[str, Any], name: str) -> ProspectorProfile:
    |         ^^^^^^^^^^
360 |         """Create profile from dictionary."""
361 |         profile = ProspectorProfile(name=name)
    |

C901 `merge_profiles` is too complex (18 > 10)
   --> src/code_scalpel/code_parsers/python_parsers/python_parsers_prospector.py:447:5
    |
447 | def merge_profiles(*profiles: ProspectorProfile) -> ProspectorProfile:
    |     ^^^^^^^^^^^^^^
448 |     """
449 |     Merge multiple profiles with later profiles taking priority.
    |

C901 `_build_command` is too complex (13 > 10)
   --> src/code_scalpel/code_parsers/python_parsers/python_parsers_prospector.py:877:9
    |
875 |         return report
876 |
877 |     def _build_command(self, path: str) -> list[str]:
    |         ^^^^^^^^^^^^^^
878 |         """Build the prospector command."""
879 |         cmd = ["prospector"]
    |

C901 `format_prospector_report` is too complex (11 > 10)
    --> src/code_scalpel/code_parsers/python_parsers/python_parsers_prospector.py:1009:5
     |
1009 | def format_prospector_report(report: ProspectorReport) -> str:
     |     ^^^^^^^^^^^^^^^^^^^^^^^^
1010 |     """Format a Prospector report for display."""
1011 |     lines = [
     |

C901 `_from_ini` is too complex (20 > 10)
   --> src/code_scalpel/code_parsers/python_parsers/python_parsers_pylint.py:922:9
    |
921 |     @classmethod
922 |     def _from_ini(cls, path: Path) -> PylintConfig:
    |         ^^^^^^^^^
923 |         """Load configuration from INI file (.pylintrc or setup.cfg)."""
924 |         parser = configparser.ConfigParser()
    |

C901 `_from_dict` is too complex (22 > 10)
   --> src/code_scalpel/code_parsers/python_parsers/python_parsers_pylint.py:982:9
    |
981 |     @classmethod
982 |     def _from_dict(cls, data: dict[str, Any]) -> PylintConfig:
    |         ^^^^^^^^^^
983 |         """Create PylintConfig from a dictionary (from pyproject.toml)."""
984 |         config = cls()
    |

C901 `find_config` is too complex (13 > 10)
    --> src/code_scalpel/code_parsers/python_parsers/python_parsers_pylint.py:1070:9
     |
1069 |     @classmethod
1070 |     def find_config(cls, start_path: Path) -> PylintConfig | None:
     |         ^^^^^^^^^^^
1071 |         """
1072 |         Find and load configuration from the nearest config file.
     |

C901 `_from_dict` is too complex (19 > 10)
   --> src/code_scalpel/code_parsers/python_parsers/python_parsers_ruff.py:518:9
    |
517 |     @classmethod
518 |     def _from_dict(cls, data: dict[str, Any]) -> RuffConfig:
    |         ^^^^^^^^^^
519 |         """Create RuffConfig from a dictionary."""
520 |         config = cls()
    |

C901 `to_cli_args` is too complex (11 > 10)
   --> src/code_scalpel/code_parsers/python_parsers/python_parsers_ruff.py:615:9
    |
613 |         return None
614 |
615 |     def to_cli_args(self) -> list[str]:
    |         ^^^^^^^^^^^
616 |         """Convert configuration to CLI arguments."""
617 |         args = []
    |

C901 `format_violations` is too complex (17 > 10)
    --> src/code_scalpel/code_parsers/python_parsers/python_parsers_ruff.py:1133:5
     |
1133 | def format_violations(
     |     ^^^^^^^^^^^^^^^^^
1134 |     violations: list[RuffViolation],
1135 |     *,
     |

C901 `resolve_to_file` is too complex (11 > 10)
   --> src/code_scalpel/code_parsers/typescript_parsers/alias_resolver.py:311:9
    |
309 |         return alias in self.aliases
310 |
311 |     def resolve_to_file(
    |         ^^^^^^^^^^^^^^^
312 |         self, import_path: str, extensions: Optional[list[str]] = None
313 |     ) -> Optional[Path]:
    |

C901 `extract_decorators_from_code` is too complex (13 > 10)
   --> src/code_scalpel/code_parsers/typescript_parsers/decorator_analyzer.py:124:9
    |
122 |         return node.decorators if hasattr(node, "decorators") else []
123 |
124 |     def extract_decorators_from_code(self, code: str) -> dict[str, Any]:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
125 |         """
126 |         Extract decorators from TypeScript source code using regex.
    |

C901 `validate_config_files` is too complex (12 > 10)
   --> src/code_scalpel/config/init_config.py:134:5
    |
134 | def validate_config_files(config_dir: Path) -> Dict[str, Any]:
    |     ^^^^^^^^^^^^^^^^^^^^^
135 |     """
136 |     Validate configuration file formats (JSON, YAML, Rego).
    |

C901 `simulate` is too complex (15 > 10)
   --> src/code_scalpel/generators/refactor_simulator.py:211:9
    |
209 |         self.strict_mode = strict_mode
210 |
211 |     def simulate(
    |         ^^^^^^^^
212 |         self,
213 |         original_code: str,
    |

C901 `_check_syntax` is too complex (13 > 10)
   --> src/code_scalpel/generators/refactor_simulator.py:511:9
    |
509 |         return "".join(patched_lines)
510 |
511 |     def _check_syntax(self, code: str, language: str) -> str | None:
    |         ^^^^^^^^^^^^^
512 |         """Check if code has valid syntax. Returns error message or None.
    |

C901 `_check_js_syntax_heuristic` is too complex (36 > 10)
   --> src/code_scalpel/generators/refactor_simulator.py:580:9
    |
578 |         return None
579 |
580 |     def _check_js_syntax_heuristic(self, code: str, language: str) -> str | None:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^
581 |         """Heuristic-based JavaScript/TypeScript syntax validation.
    |

C901 `_analyze_structural_changes` is too complex (13 > 10)
   --> src/code_scalpel/generators/refactor_simulator.py:954:9
    |
952 |         return issues
953 |
954 |     def _analyze_structural_changes(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^
955 |         self, original: str, new_code: str, language: str
956 |     ) -> dict[str, Any]:
    |

C901 `_extract_js_symbols_from_tree` is too complex (17 > 10)
    --> src/code_scalpel/generators/refactor_simulator.py:1089:9
     |
1087 |         return self._extract_js_structure_regex(code)
1088 |
1089 |     def _extract_js_symbols_from_tree(self, node, structure: dict[str, set]) -> None:
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
1090 |         """Extract symbols from tree-sitter parse tree.
     |

C901 `_analyze_test_impact` is too complex (15 > 10)
    --> src/code_scalpel/generators/refactor_simulator.py:1350:9
     |
1348 |         return round(confidence, 3), factors
1349 |
1350 |     def _analyze_test_impact(
     |         ^^^^^^^^^^^^^^^^^^^^
1351 |         self,
1352 |         original_code: str,
     |

C901 `simulate_multi_file` is too complex (11 > 10)
    --> src/code_scalpel/generators/refactor_simulator.py:1564:9
     |
1562 |         return strategy
1563 |
1564 |     def simulate_multi_file(
     |         ^^^^^^^^^^^^^^^^^^^
1565 |         self,
1566 |         file_changes: list[dict[str, str]],
     |

C901 `_predict_regression_impact` is too complex (14 > 10)
    --> src/code_scalpel/generators/refactor_simulator.py:1778:9
     |
1776 |         return type_errors
1777 |
1778 |     def _predict_regression_impact(
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^
1779 |         self, original_code: str, new_code: str, project_root: str | None = None
1780 |     ) -> dict[str, Any]:
     |

C901 `_parse_crash_log` is too complex (14 > 10)
   --> src/code_scalpel/generators/test_generator.py:635:9
    |
633 |         )
634 |
635 |     def _parse_crash_log(
    |         ^^^^^^^^^^^^^^^^
636 |         self, crash_log: str, function_name: str, language: str
637 |     ) -> dict[str, Any]:
    |

C901 `_detect_main_function` is too complex (11 > 10)
   --> src/code_scalpel/generators/test_generator.py:714:9
    |
712 |         return bug_info
713 |
714 |     def _detect_main_function(self, code: str, language: str) -> str:
    |         ^^^^^^^^^^^^^^^^^^^^^
715 |         """Detect the main function to test."""
716 |         if language == "python":
    |

C901 `_extract_test_cases` is too complex (15 > 10)
   --> src/code_scalpel/generators/test_generator.py:894:9
    |
892 |         return 1 if should_satisfy else -1
893 |
894 |     def _extract_test_cases(
    |         ^^^^^^^^^^^^^^^^^^^
895 |         self,
896 |         symbolic_result: dict[str, Any],
    |

C901 `_safe_interpret_return` is too complex (34 > 10)
    --> src/code_scalpel/generators/test_generator.py:1007:9
     |
1005 |         return test_cases
1006 |
1007 |     def _safe_interpret_return(
     |         ^^^^^^^^^^^^^^^^^^^^^^
1008 |         self,
1009 |         code: str,
     |

C901 `eval_expr` is too complex (21 > 10)
    --> src/code_scalpel/generators/test_generator.py:1043:13
     |
1041 |             return None
1042 |
1043 |         def eval_expr(expr: ast.AST) -> Any:
     |             ^^^^^^^^^
1044 |             if isinstance(expr, ast.Constant):
1045 |                 return expr.value
     |

C901 `_to_python_value` is too complex (19 > 10)
    --> src/code_scalpel/generators/test_generator.py:1152:9
     |
1150 |         return {}
1151 |
1152 |     def _to_python_value(self, value: Any, expected_type: str | None = None) -> Any:
     |         ^^^^^^^^^^^^^^^^
1153 |         """Convert Z3 or other symbolic values to Python natives.
     |

C901 `_infer_expected_result` is too complex (25 > 10)
    --> src/code_scalpel/generators/test_generator.py:1301:9
     |
1299 |         return None
1300 |
1301 |     def _infer_expected_result(
     |         ^^^^^^^^^^^^^^^^^^^^^^
1302 |         self, conditions: list[str], return_map: dict[str, Any], inputs: dict[str, Any]
1303 |     ) -> Any:
     |

C901 `_evaluate_semantic` is too complex (11 > 10)
   --> src/code_scalpel/governance/unified_governance.py:383:9
    |
381 |         return decision
382 |
383 |     def _evaluate_semantic(
    |         ^^^^^^^^^^^^^^^^^^
384 |         self, operation: Dict[str, Any]
385 |     ) -> List[GovernanceViolation]:
    |

C901 `matches` is too complex (12 > 10)
  --> src/code_scalpel/graph/graph_query.py:54:9
   |
52 |     value: Any
53 |
54 |     def matches(self, node_data: Dict[str, Any]) -> bool:
   |         ^^^^^^^
55 |         """Check if a node matches this predicate."""
56 |         actual = node_data.get(self.field)
   |

C901 `_bfs_paths` is too complex (16 > 10)
   --> src/code_scalpel/graph/graph_query.py:442:9
    |
440 |         return paths
441 |
442 |     def _bfs_paths(
    |         ^^^^^^^^^^
443 |         self,
444 |         start_id: str,
    |

C901 `traverse` is too complex (12 > 10)
   --> src/code_scalpel/graph/graph_query.py:542:9
    |
540 |         return matching
541 |
542 |     def traverse(
    |         ^^^^^^^^
543 |         self,
544 |         start_id: str,
    |

C901 `_evaluate_path` is too complex (28 > 10)
   --> src/code_scalpel/graph/path_constraints.py:263:9
    |
261 |         return paths
262 |
263 |     def _evaluate_path(
    |         ^^^^^^^^^^^^^^
264 |         self,
265 |         path_node_ids: List[str],
    |

C901 `_get_constraint_names` is too complex (11 > 10)
   --> src/code_scalpel/graph/path_constraints.py:459:9
    |
457 |         )
458 |
459 |     def _get_constraint_names(self, constraints: ConstraintSet) -> List[str]:
    |         ^^^^^^^^^^^^^^^^^^^^^
460 |         """Get list of constraint names being applied."""
461 |         names = []
    |

C901 `_calculate_similarity` is too complex (12 > 10)
   --> src/code_scalpel/graph/semantic_neighbors.py:274:9
    |
272 |         )
273 |
274 |     def _calculate_similarity(
    |         ^^^^^^^^^^^^^^^^^^^^^
275 |         self,
276 |         center: FunctionSignature,
    |

C901 `_weighted_traverse` is too complex (13 > 10)
   --> src/code_scalpel/graph/traversal_rules.py:374:9
    |
372 |         )
373 |
374 |     def _weighted_traverse(
    |         ^^^^^^^^^^^^^^^^^^
375 |         self,
376 |         start_id: str,
    |

C901 `find_paths_with_rules` is too complex (14 > 10)
   --> src/code_scalpel/graph/traversal_rules.py:482:9
    |
480 |         return neighbors
481 |
482 |     def find_paths_with_rules(
    |         ^^^^^^^^^^^^^^^^^^^^^
483 |         self,
484 |         start_id: str,
    |

C901 `get_neighborhood` is too complex (17 > 10)
   --> src/code_scalpel/graph_engine/graph.py:351:9
    |
350 |     # [20251216_FEATURE] v2.5.0 - Graph Neighborhood View (k-hop subgraph extraction)
351 |     def get_neighborhood(
    |         ^^^^^^^^^^^^^^^^
352 |         self,
353 |         center_node_id: str,
    |

C901 `_validate_service` is too complex (11 > 10)
   --> src/code_scalpel/integrations/protocol_analyzers/grpc/contract_analyzer.py:501:9
    |
499 |         return issues
500 |
501 |     def _validate_service(
    |         ^^^^^^^^^^^^^^^^^
502 |         self, service: GrpcService, contract: GrpcContract
503 |     ) -> List[ContractIssue]:
    |

C901 `_detect_library` is too complex (12 > 10)
   --> src/code_scalpel/integrations/protocol_analyzers/kafka/taint_tracker.py:525:9
    |
523 |         return result
524 |
525 |     def _detect_library(self, source_code: str, language: str) -> KafkaLibrary:
    |         ^^^^^^^^^^^^^^^
526 |         """Detect which Kafka library is being used."""
527 |         if language == "python":
    |

C901 `_analyze_python_ast` is too complex (38 > 10)
   --> src/code_scalpel/integrations/protocol_analyzers/kafka/taint_tracker.py:588:9
    |
586 |         return self._get_variable_name(node)
587 |
588 |     def _analyze_python_ast(
    |         ^^^^^^^^^^^^^^^^^^^
589 |         self,
590 |         tree: ast.AST,
    |

C901 `visit_Call` is too complex (27 > 10)
   --> src/code_scalpel/integrations/protocol_analyzers/kafka/taint_tracker.py:639:17
    |
637 |                 self._handle_function(node)
638 |
639 |             def visit_Call(self, node: ast.Call):
    |                 ^^^^^^^^^^
640 |                 # Check for producer.send() or producer.produce()
641 |                 if isinstance(node.func, ast.Attribute):
    |

C901 `_compare_json_schema_recursive` is too complex (11 > 10)
   --> src/code_scalpel/integrations/protocol_analyzers/schema/drift_detector.py:931:9
    |
929 |         return result
930 |
931 |     def _compare_json_schema_recursive(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
932 |         self,
933 |         old: Dict[str, Any],
    |

C901 `create_app` is too complex (29 > 10)
   --> src/code_scalpel/integrations/rest_api_server.py:127:5
    |
127 | def create_app(config: Optional[MCPServerConfig] = None) -> Flask:
    |     ^^^^^^^^^^
128 |     """
129 |     Create and configure the Flask MCP server application.
    |

C901 `visit_class_declaration` is too complex (15 > 10)
   --> src/code_scalpel/ir/normalizers/java_normalizer.py:187:9
    |
185 |         )
186 |
187 |     def visit_class_declaration(self, node: Any) -> IRClassDef:
    |         ^^^^^^^^^^^^^^^^^^^^^^^
188 |         """
189 |         class MyClass { ... }
    |

C901 `visit_record_declaration` is too complex (11 > 10)
   --> src/code_scalpel/ir/normalizers/java_normalizer.py:258:9
    |
256 |     # =========================================================================
257 |
258 |     def visit_record_declaration(self, node: Any) -> IRClassDef:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^
259 |         """
260 |         public record Point(int x, int y) { ... }
    |

C901 `visit_try_statement` is too complex (13 > 10)
   --> src/code_scalpel/ir/normalizers/java_normalizer.py:666:9
    |
664 |     # =========================================================================
665 |
666 |     def visit_try_statement(self, node: Any) -> IRTry:
    |         ^^^^^^^^^^^^^^^^^^^
667 |         """
668 |         try { ... } catch (Exception e) { ... } finally { ... }
    |

C901 `_normalize_switch` is too complex (18 > 10)
   --> src/code_scalpel/ir/normalizers/java_normalizer.py:761:9
    |
759 |         return self._normalize_switch(node)
760 |
761 |     def _normalize_switch(self, node: Any) -> IRSwitch:
    |         ^^^^^^^^^^^^^^^^^
762 |         """Internal switch normalization."""
763 |         discriminant = None
    |

C901 `_normalize_import_statement` is too complex (13 > 10)
    --> src/code_scalpel/ir/normalizers/javascript_normalizer.py:1612:9
     |
1610 |     # =========================================================================
1611 |
1612 |     def _normalize_import_statement(self, node) -> IRImport:
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^
1613 |         """
1614 |         Normalize ES6 import statement.
     |

C901 `compute_effective_tier_for_startup` is too complex (24 > 10)
  --> src/code_scalpel/licensing/authorization.py:25:5
   |
25 | def compute_effective_tier_for_startup(
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
26 |     *,
27 |     requested_tier: str | None,
   |

C901 `generate_license` is too complex (11 > 10)
  --> src/code_scalpel/licensing/jwt_generator.py:97:5
   |
97 | def generate_license(
   |     ^^^^^^^^^^^^^^^^
98 |     tier: str,
99 |     customer_id: str,
   |

C901 `_revocation_error_if_revoked` is too complex (13 > 10)
   --> src/code_scalpel/licensing/jwt_validator.py:473:9
    |
471 |         return None
472 |
473 |     def _revocation_error_if_revoked(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
474 |         self,
475 |         jti: str,
    |

C901 `validate_token` is too complex (21 > 10)
   --> src/code_scalpel/licensing/jwt_validator.py:559:9
    |
557 |             return "License revocation list invalid"
558 |
559 |     def validate_token(self, token: str) -> JWTLicenseData:
    |         ^^^^^^^^^^^^^^
560 |         """
561 |         Validate a JWT license token.
    |

C901 `remote_verify` is too complex (12 > 10)
   --> src/code_scalpel/licensing/remote_verifier.py:299:5
    |
299 | def remote_verify(token: str, *, environment: str | None) -> VerifiedEntitlements:
    |     ^^^^^^^^^^^^^
300 |     base = verifier_base_url()
301 |     if not base:
    |

C901 `_classify_failure_message` is too complex (11 > 10)
   --> src/code_scalpel/mcp/contract.py:201:5
    |
201 | def _classify_failure_message(message: str | None) -> ErrorCode | None:
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^
202 |     if not message:
203 |         return None
    |

C901 `_attempt_resolution` is too complex (17 > 10)
   --> src/code_scalpel/mcp/path_resolver.py:297:9
    |
295 |             raise FileNotFoundError(self._format_error_message(path, result))
296 |
297 |     def _attempt_resolution(
    |         ^^^^^^^^^^^^^^^^^^^
298 |         self, path: str, project_root: Optional[str]
299 |     ) -> PathResolutionResult:
    |

C901 `filter_response` is too complex (11 > 10)
   --> src/code_scalpel/mcp/response_config.py:170:9
    |
168 |         return self.config["global"].get("exclude_default_values", True)
169 |
170 |     def filter_response(
    |         ^^^^^^^^^^^^^^^
171 |         self,
172 |         data: Dict[str, Any],
    |

C901 `_evaluate_change_budget_for_write_tool` is too complex (35 > 10)
   --> src/code_scalpel/mcp/server.py:352:5
    |
352 | def _evaluate_change_budget_for_write_tool(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
353 |     *,
354 |     tool_id: str,
    |

C901 `_maybe_enforce_governance_before_tool` is too complex (24 > 10)
   --> src/code_scalpel/mcp/server.py:678:5
    |
678 | def _maybe_enforce_governance_before_tool(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
679 |     *,
680 |     tool_id: str,
    |

C901 `_add_tool_with_envelope_output` is too complex (19 > 10)
    --> src/code_scalpel/mcp/server.py:2427:5
     |
2427 | def _add_tool_with_envelope_output(
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
2428 |     fn: Callable[..., Any], **add_tool_kwargs: Any
2429 | ) -> Any:
     |

C901 `_enveloped_run` is too complex (18 > 10)
    --> src/code_scalpel/mcp/server.py:2441:15
     |
2439 |     original_run = tool.run
2440 |
2441 |     async def _enveloped_run(
     |               ^^^^^^^^^^^^^^
2442 |         arguments: dict[str, Any], context: Any = None, convert_result: bool = False
2443 |     ) -> dict[str, Any]:
     |

C901 `_detect_code_smells_python` is too complex (14 > 10)
    --> src/code_scalpel/mcp/server.py:2722:5
     |
2722 | def _detect_code_smells_python(tree: ast.AST, code: str) -> list[str]:
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^
2723 |     """
2724 |     Detect code smells in Python code.
     |

C901 `_analyze_javascript_code` is too complex (27 > 10)
    --> src/code_scalpel/mcp/server.py:3018:5
     |
3018 | def _analyze_javascript_code(code: str, is_typescript: bool = False) -> AnalysisResult:
     |     ^^^^^^^^^^^^^^^^^^^^^^^^
3019 |     """
3020 |     Analyze JavaScript/TypeScript code using tree-sitter.
     |

C901 `walk_tree` is too complex (19 > 10)
    --> src/code_scalpel/mcp/server.py:3046:13
     |
3044 |         imports = []
3045 |
3046 |         def walk_tree(node, depth=0):
     |             ^^^^^^^^^
3047 |             """Walk tree-sitter tree to extract structure."""
3048 |             node_type = node.type
     |

C901 `_detect_dead_code_hints_python` is too complex (24 > 10)
    --> src/code_scalpel/mcp/server.py:3263:5
     |
3263 | def _detect_dead_code_hints_python(tree: ast.AST, code: str) -> list[str]:
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
3264 |     """Best-effort dead code hints for Python.
     |

C901 `_summarize_types_python` is too complex (14 > 10)
    --> src/code_scalpel/mcp/server.py:3371:5
     |
3371 | def _summarize_types_python(tree: ast.AST) -> dict[str, Any]:
     |     ^^^^^^^^^^^^^^^^^^^^^^^
3372 |     total_funcs = 0
3373 |     funcs_with_any_annotations = 0
     |

C901 `_analyze_code_sync` is too complex (61 > 10)
    --> src/code_scalpel/mcp/server.py:3510:5
     |
3510 | def _analyze_code_sync(
     |     ^^^^^^^^^^^^^^^^^^
3511 |     code: str, language: str = "auto", file_path: str | None = None
3512 | ) -> AnalysisResult:
     |

C901 `_security_scan_sync` is too complex (74 > 10)
    --> src/code_scalpel/mcp/server.py:3962:5
     |
3962 | def _security_scan_sync(
     |     ^^^^^^^^^^^^^^^^^^^
3963 |     code: Optional[str] = None,
3964 |     file_path: Optional[str] = None,
     |

C901 `_unified_sink_detect_sync` is too complex (38 > 10)
    --> src/code_scalpel/mcp/server.py:4974:5
     |
4974 | def _unified_sink_detect_sync(
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^
4975 |     code: str,
4976 |     language: str,
     |

C901 `_type_evaporation_scan_sync` is too complex (12 > 10)
    --> src/code_scalpel/mcp/server.py:5365:5
     |
5365 | def _type_evaporation_scan_sync(
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
5366 |     frontend_code: str,
5367 |     backend_code: str,
     |

C901 `_generate_type_compliance_report` is too complex (18 > 10)
    --> src/code_scalpel/mcp/server.py:6278:5
     |
6278 | def _generate_type_compliance_report(
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
6279 |     vulnerabilities: list[Any],
6280 |     api_contract: dict[str, Any] | None,
     |

C901 `_scan_dependencies_sync` is too complex (35 > 10)
    --> src/code_scalpel/mcp/server.py:7085:5
     |
7085 | def _scan_dependencies_sync(
     |     ^^^^^^^^^^^^^^^^^^^^^^^
7086 |     project_root: str | None = None,
7087 |     path: str | None = None,
     |

C901 `_extract_severity` is too complex (13 > 10)
    --> src/code_scalpel/mcp/server.py:7371:5
     |
7371 | def _extract_severity(vuln: dict[str, Any]) -> str:
     |     ^^^^^^^^^^^^^^^^^
7372 |     """Extract severity from OSV vulnerability data.
     |

C901 `_detect_requested_constraint_types` is too complex (20 > 10)
    --> src/code_scalpel/mcp/server.py:7733:5
     |
7733 | def _detect_requested_constraint_types(code: str) -> set[str]:
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
7734 |     """Best-effort extraction of constraint types implied by code.
     |

C901 `_symbolic_execute_sync` is too complex (30 > 10)
    --> src/code_scalpel/mcp/server.py:8021:5
     |
8021 | def _symbolic_execute_sync(
     |     ^^^^^^^^^^^^^^^^^^^^^^
8022 |     code: str,
8023 |     max_paths: int | None = None,
     |

C901 `_generate_tests_sync` is too complex (22 > 10)
    --> src/code_scalpel/mcp/server.py:8299:5
     |
8299 | def _generate_tests_sync(
     |     ^^^^^^^^^^^^^^^^^^^^
8300 |     code: str | None = None,
8301 |     file_path: str | None = None,
     |

C901 `_simulate_refactor_sync` is too complex (20 > 10)
    --> src/code_scalpel/mcp/server.py:8640:5
     |
8640 | def _simulate_refactor_sync(
     |     ^^^^^^^^^^^^^^^^^^^^^^^
8641 |     original_code: str,
8642 |     new_code: str | None = None,
     |

C901 `_crawl_project_discovery` is too complex (27 > 10)
    --> src/code_scalpel/mcp/server.py:8881:5
     |
8881 | def _crawl_project_discovery(
     |     ^^^^^^^^^^^^^^^^^^^^^^^^
8882 |     root_path: str,
8883 |     exclude_dirs: list[str] | None = None,
     |

C901 `_crawl_project_sync` is too complex (95 > 10)
    --> src/code_scalpel/mcp/server.py:9111:5
     |
9111 | def _crawl_project_sync(
     |     ^^^^^^^^^^^^^^^^^^^
9112 |     root_path: str,
9113 |     exclude_dirs: list[str] | None = None,
     |

C901 `extract_code` is too complex (41 > 10)
    --> src/code_scalpel/mcp/server.py:9926:11
     |
9925 | @mcp.tool()
9926 | async def extract_code(
     |           ^^^^^^^^^^^^
9927 |     target_type: str,
9928 |     target_name: str,
     |

C901 `_update_cross_file_references` is too complex (15 > 10)
     --> src/code_scalpel/mcp/server.py:10627:11
      |
10627 | async def _update_cross_file_references(
      |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
10628 |     modified_file: str, target_type: str, target_name: str, new_code: str
10629 | ) -> dict[str, Any]:
      |

C901 `update_symbol` is too complex (74 > 10)
     --> src/code_scalpel/mcp/server.py:10989:11
      |
10988 | @mcp.tool()
10989 | async def update_symbol(
      |           ^^^^^^^^^^^^^
10990 |     file_path: str,
10991 |     target_type: str,
      |

C901 `_semantic_name_check` is too complex (13 > 10)
     --> src/code_scalpel/mcp/server.py:11083:9
      |
11081 |     validation_level = str(limits.get("validation_level", "syntax"))
11082 |
11083 |     def _semantic_name_check() -> str | None:
      |         ^^^^^^^^^^^^^^^^^^^^
11084 |         """Best-effort semantic validation that the replacement defines the target."""
11085 |         try:
      |

C901 `crawl_project` is too complex (11 > 10)
     --> src/code_scalpel/mcp/server.py:12066:11
      |
12065 | @mcp.tool()
12066 | async def crawl_project(
      |           ^^^^^^^^^^^^^
12067 |     root_path: str | None = None,
12068 |     exclude_dirs: list[str] | None = None,
      |

C901 `_get_file_context_sync` is too complex (57 > 10)
     --> src/code_scalpel/mcp/server.py:13521:5
      |
13521 | def _get_file_context_sync(
      |     ^^^^^^^^^^^^^^^^^^^^^^
13522 |     file_path: str, tier: str | None = None, capabilities: dict | None = None
13523 | ) -> FileContextResult:
      |

C901 `_detect_code_smells` is too complex (18 > 10)
     --> src/code_scalpel/mcp/server.py:13857:5
      |
13857 | def _detect_code_smells(
      |     ^^^^^^^^^^^^^^^^^^^
13858 |     tree: ast.Module, code: str, lines: list[str]
13859 | ) -> list[dict[str, Any]]:
      |

C901 `_get_symbol_references_sync` is too complex (138 > 10)
     --> src/code_scalpel/mcp/server.py:14394:5
      |
14394 | def _get_symbol_references_sync(
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
14395 |     symbol_name: str,
14396 |     project_root: str | None = None,
      |

C901 `_get_call_graph_sync` is too complex (27 > 10)
     --> src/code_scalpel/mcp/server.py:15350:5
      |
15350 | def _get_call_graph_sync(
      |     ^^^^^^^^^^^^^^^^^^^^
15351 |     project_root: str | None,
15352 |     entry_point: str | None,
      |

C901 `get_graph_neighborhood` is too complex (44 > 10)
     --> src/code_scalpel/mcp/server.py:15867:11
      |
15866 | @mcp.tool()
15867 | async def get_graph_neighborhood(
      |           ^^^^^^^^^^^^^^^^^^^^^^
15868 |     center_node_id: str,
15869 |     k: int = 2,
      |

C901 `_get_project_map_sync` is too complex (123 > 10)
     --> src/code_scalpel/mcp/server.py:16561:5
      |
16561 | def _get_project_map_sync(
      |     ^^^^^^^^^^^^^^^^^^^^^
16562 |     project_root: str | None,
16563 |     include_complexity: bool,
      |

C901 `_get_cross_file_dependencies_sync` is too complex (63 > 10)
     --> src/code_scalpel/mcp/server.py:17728:5
      |
17728 | def _get_cross_file_dependencies_sync(
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
17729 |     target_file: str,
17730 |     target_symbol: str,
      |

C901 `_cross_file_security_scan_sync` is too complex (45 > 10)
     --> src/code_scalpel/mcp/server.py:18407:5
      |
18407 | def _cross_file_security_scan_sync(
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
18408 |     project_root: str | None,
18409 |     entry_points: list[str] | None,
      |

C901 `_validate_paths_sync` is too complex (32 > 10)
     --> src/code_scalpel/mcp/server.py:18875:5
      |
18875 | def _validate_paths_sync(
      |     ^^^^^^^^^^^^^^^^^^^^
18876 |     paths: list[str],
18877 |     project_root: str | None,
      |

C901 `_verify_policy_integrity_sync` is too complex (20 > 10)
     --> src/code_scalpel/mcp/server.py:19209:5
      |
19209 | def _verify_policy_integrity_sync(
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
19210 |     policy_dir: str | None = None,
19211 |     manifest_source: str = "file",
      |

C901 `run_server` is too complex (14 > 10)
     --> src/code_scalpel/mcp/server.py:19693:5
      |
19693 | def run_server(
      |     ^^^^^^^^^^
19694 |     transport: str = "stdio",
19695 |     host: str = "127.0.0.1",
      |

C901 `_find_data_flow_anomalies` is too complex (12 > 10)
   --> src/code_scalpel/pdg_tools/analyzer.py:203:9
    |
201 |         return slice_graph
202 |
203 |     def _find_data_flow_anomalies(self) -> list[DataFlowAnomaly]:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^
204 |         """Find data flow anomalies in the code."""
205 |         anomalies = []
    |

C901 `visit_Assign` is too complex (14 > 10)
   --> src/code_scalpel/pdg_tools/builder.py:375:9
    |
373 |         self.exception_deps.pop()
374 |
375 |     def visit_Assign(self, node: ast.Assign):
    |         ^^^^^^^^^^^^
376 |         """Handle assignment statements."""
377 |         node_id = self._get_node_id("assign")
    |

C901 `__init__` is too complex (16 > 10)
  --> src/code_scalpel/policy_engine/code_policy_check/analyzer.py:67:9
   |
65 |     """
66 |
67 |     def __init__(
   |         ^^^^^^^^
68 |         self,
69 |         tier: str = "community",
   |

C901 `check_files` is too complex (12 > 10)
   --> src/code_scalpel/policy_engine/code_policy_check/analyzer.py:191:9
    |
189 |         self._audit_entries: list[AuditEntry] = []
190 |
191 |     def check_files(
    |         ^^^^^^^^^^^
192 |         self,
193 |         paths: list[str],
    |

C901 `_check_file` is too complex (16 > 10)
   --> src/code_scalpel/policy_engine/code_policy_check/analyzer.py:364:9
    |
362 |         return limits.get(self.tier, {}).get(limit_name)
363 |
364 |     def _check_file(
    |         ^^^^^^^^^^^
365 |         self, file_path: str, rules: list[str] | None
366 |     ) -> tuple[list[PolicyViolation], int]:
    |

C901 `_check_eslint` is too complex (17 > 10)
   --> src/code_scalpel/policy_engine/code_policy_check/analyzer.py:509:9
    |
507 |         return violations
508 |
509 |     def _check_eslint(self, file_path: str) -> list[PolicyViolation]:
    |         ^^^^^^^^^^^^^
510 |         """Run ESLint checks for JS/TS (best-effort)."""
511 |         violations: list[PolicyViolation] = []
    |

C901 `_check_best_practices` is too complex (11 > 10)
   --> src/code_scalpel/policy_engine/code_policy_check/analyzer.py:776:9
    |
774 |         return violations
775 |
776 |     def _check_best_practices(self, file_path: str) -> list[BestPracticeViolation]:
    |         ^^^^^^^^^^^^^^^^^^^^^
777 |         """
778 |         Check for best practice violations (Pro tier).
    |

C901 `_check_security_patterns` is too complex (11 > 10)
   --> src/code_scalpel/policy_engine/code_policy_check/analyzer.py:835:9
    |
833 |         return violations
834 |
835 |     def _check_security_patterns(self, file_path: str) -> list[SecurityWarning]:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^
836 |         """
837 |         Check for security issues (Pro tier).
    |

C901 `_basic_validate_rego` is too complex (21 > 10)
   --> src/code_scalpel/policy_engine/policy_engine.py:442:9
    |
441 |     @staticmethod
442 |     def _basic_validate_rego(rule: str, policy_name: str) -> None:
    |         ^^^^^^^^^^^^^^^^^^^^
443 |         if not rule or not isinstance(rule, str):
444 |             raise PolicyError(
    |

C901 `evaluate` is too complex (13 > 10)
   --> src/code_scalpel/policy_engine/policy_engine.py:569:9
    |
567 |                 )
568 |
569 |     def evaluate(self, operation: Operation) -> PolicyDecision:
    |         ^^^^^^^^
570 |         """
571 |         Evaluate operation against all policies.
    |

C901 `_evaluate_without_opa` is too complex (11 > 10)
   --> src/code_scalpel/policy_engine/policy_engine.py:720:9
    |
718 |         )
719 |
720 |     def _evaluate_without_opa(self, operation: Operation) -> PolicyDecision:
    |         ^^^^^^^^^^^^^^^^^^^^^
721 |         """Evaluate policies without OPA using a conservative local interpreter."""
722 |         if self._semantic_analyzer is None:
    |

C901 `_detect_python_sql` is too complex (13 > 10)
   --> src/code_scalpel/policy_engine/semantic_analyzer.py:138:9
    |
136 |             return self._contains_sql_keywords_text(code)
137 |
138 |     def _detect_python_sql(self, code: str) -> bool:
    |         ^^^^^^^^^^^^^^^^^^
139 |         """
140 |         Detect SQL in Python code.
    |

C901 `contains_command_injection` is too complex (11 > 10)
   --> src/code_scalpel/policy_engine/semantic_analyzer.py:497:9
    |
495 |         return False
496 |
497 |     def contains_command_injection(self, code: str, language: str) -> bool:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^
498 |         """
499 |         Detect Command Injection vulnerabilities.
    |

C901 `resolve_to_file` is too complex (11 > 10)
   --> src/code_scalpel/polyglot/alias_resolver.py:311:9
    |
309 |         return alias in self.aliases
310 |
311 |     def resolve_to_file(
    |         ^^^^^^^^^^^^^^^
312 |         self, import_path: str, extensions: Optional[list[str]] = None
313 |     ) -> Optional[Path]:
    |

C901 `_extract_from_ir` is too complex (16 > 10)
   --> src/code_scalpel/polyglot/extractor.py:413:9
    |
411 |             )
412 |
413 |     def _extract_from_ir(
    |         ^^^^^^^^^^^^^^^^
414 |         self, target_type: str, target_name: str
415 |     ) -> PolyglotExtractionResult:
    |

C901 `extract_decorators_from_code` is too complex (13 > 10)
   --> src/code_scalpel/polyglot/typescript/decorator_analyzer.py:124:9
    |
122 |         return node.decorators if hasattr(node, "decorators") else []
123 |
124 |     def extract_decorators_from_code(self, code: str) -> dict[str, Any]:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
125 |         """
126 |         Extract decorators from TypeScript source code using regex.
    |

C901 `_check_files_batch` is too complex (26 > 10)
   --> src/code_scalpel/quality_assurance/error_scanner.py:306:9
    |
304 |         return sorted(python_files)
305 |
306 |     def _check_files_batch(self, files: list[Path]) -> dict[str, list[CodeError]]:
    |         ^^^^^^^^^^^^^^^^^^
307 |         """
308 |         Check a batch of files for errors using mypy, flake8, pylint, and ruff.
    |

C901 `analyze` is too complex (12 > 10)
   --> src/code_scalpel/security/analyzers/cross_file_taint.py:508:9
    |
506 |         return self._built
507 |
508 |     def analyze(
    |         ^^^^^^^
509 |         self,
510 |         entry_points: Optional[List[str]] = None,
    |

C901 `_trace_cross_file_flows` is too complex (13 > 10)
   --> src/code_scalpel/security/analyzers/cross_file_taint.py:883:9
    |
881 |         return args
882 |
883 |     def _trace_cross_file_flows(
    |         ^^^^^^^^^^^^^^^^^^^^^^^
884 |         self,
885 |         result: CrossFileTaintResult,
    |

C901 `_get_enclosing_function_name` is too complex (11 > 10)
    --> src/code_scalpel/security/analyzers/cross_file_taint.py:1057:9
     |
1055 |                             result.taint_flows.append(flow)
1056 |
1057 |     def _get_enclosing_function_name(self, module: str, line: int) -> Optional[str]:
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
1058 |         """Best-effort: return the function name in `module` that contains `line`."""
1059 |         if module not in self._module_function_spans:
     |

C901 `visit_Assign` is too complex (16 > 10)
    --> src/code_scalpel/security/analyzers/cross_file_taint.py:1281:9
     |
1279 |         self.current_var: Optional[str] = None
1280 |
1281 |     def visit_Assign(self, node: ast.Assign) -> None:
     |         ^^^^^^^^^^^^
1282 |         """Track variable assignments."""
1283 |         # Check if RHS is a taint source
     |

C901 `visit_Call` is too complex (23 > 10)
    --> src/code_scalpel/security/analyzers/cross_file_taint.py:1377:9
     |
1375 |         return False
1376 |
1377 |     def visit_Call(self, node: ast.Call) -> None:
     |         ^^^^^^^^^^
1378 |         """Check for dangerous sinks."""
1379 |         callee = self._get_callee_name(node)
     |

C901 `is_test_code` is too complex (14 > 10)
  --> src/code_scalpel/security/analyzers/false_positive_analyzer.py:35:9
   |
33 |         pass
34 |
35 |     def is_test_code(self, code: str, filename: str = "") -> bool:
   |         ^^^^^^^^^^^^
36 |         """
37 |         Detect if code is a test file.
   |

C901 `_analyze_node` is too complex (28 > 10)
   --> src/code_scalpel/security/analyzers/security_analyzer.py:393:9
    |
391 |         return result
392 |
393 |     def _analyze_node(self, node: ast.AST, result: SecurityAnalysisResult) -> None:
    |         ^^^^^^^^^^^^^
394 |         """Recursively analyze an AST node."""
    |

C901 `_analyze_assignment` is too complex (14 > 10)
   --> src/code_scalpel/security/analyzers/security_analyzer.py:589:9
    |
587 |             parts.append(node)
588 |
589 |     def _analyze_assignment(self, node: ast.Assign) -> None:
    |         ^^^^^^^^^^^^^^^^^^^
590 |         """Analyze an assignment for taint propagation."""
591 |         # Get target name(s)
    |

C901 `_analyze_call` is too complex (24 > 10)
   --> src/code_scalpel/security/analyzers/security_analyzer.py:677:9
    |
675 |         return None
676 |
677 |     def _analyze_call(self, node: ast.Call, location: Tuple[int, int]) -> None:
    |         ^^^^^^^^^^^^^
678 |         """Analyze a function call for sink detection."""
679 |         if not self._taint_tracker:
    |

C901 `_extract_variable_names` is too complex (11 > 10)
   --> src/code_scalpel/security/analyzers/security_analyzer.py:955:9
    |
953 |         self._taint_tracker._vulnerabilities.append(vuln)
954 |
955 |     def _extract_variable_names(self, node: ast.expr) -> List[str]:
    |         ^^^^^^^^^^^^^^^^^^^^^^^
956 |         """Extract all variable names referenced in an expression."""
957 |         names = []
    |

C901 `load_sanitizers_from_config` is too complex (11 > 10)
   --> src/code_scalpel/security/analyzers/taint_tracker.py:609:5
    |
609 | def load_sanitizers_from_config(config_path: Optional[str] = None) -> int:
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
610 |     """
611 |     Load custom sanitizers from pyproject.toml.
    |

C901 `has_input_validation` is too complex (17 > 10)
    --> src/code_scalpel/security/analyzers/taint_tracker.py:2298:5
     |
2298 | def has_input_validation(node: ast.AST) -> bool:
     |     ^^^^^^^^^^^^^^^^^^^^
2299 |     """
2300 |     [20251216_BUGFIX] Accepts both FunctionDef and Lambda nodes for input validation detection.
     |

C901 `detect_ssr_vulnerabilities` is too complex (19 > 10)
    --> src/code_scalpel/security/analyzers/taint_tracker.py:2384:5
     |
2384 | def detect_ssr_vulnerabilities(
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^
2385 |     tree: ast.AST,
2386 |     framework: Optional[str] = None,
     |

C901 `_parse_license_text` is too complex (15 > 10)
   --> src/code_scalpel/security/dependencies/license_compliance.py:198:9
    |
196 |         return common_licenses.get(package_name.lower(), "UNKNOWN")
197 |
198 |     def _parse_license_text(self, text: str) -> str | None:
    |         ^^^^^^^^^^^^^^^^^^^
199 |         """Parse license from LICENSE file text."""
200 |         text_upper = text.upper()
    |

C901 `_parse_severity` is too complex (21 > 10)
   --> src/code_scalpel/security/dependencies/osv_client.py:248:9
    |
246 |         raise OSVError(f"Request failed after {MAX_RETRIES} retries: {last_error}")
247 |
248 |     def _parse_severity(self, vuln_data: Dict[str, Any]) -> str:
    |         ^^^^^^^^^^^^^^^
249 |         """
250 |         Extract severity from OSV vulnerability data.
    |

C901 `_extract_calls_and_imports` is too complex (14 > 10)
   --> src/code_scalpel/security/dependencies/vulnerability_reachability.py:146:9
    |
144 |                 logger.debug(f"Failed to parse {py_file}: {e}")
145 |
146 |     def _extract_calls_and_imports(self, tree: ast.AST, file_path: Path) -> None:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^
147 |         """Extract function calls and imports from AST."""
148 |         module_name = file_path.stem
    |

C901 `parse_pyproject_toml` is too complex (16 > 10)
   --> src/code_scalpel/security/dependencies/vulnerability_scanner.py:383:9
    |
382 |     @staticmethod
383 |     def parse_pyproject_toml(file_path: Path) -> list[Dependency]:
    |         ^^^^^^^^^^^^^^^^^^^^
384 |         """Parse Python pyproject.toml file (PEP 621 and Poetry formats).
    |

C901 `_parse_vulnerability` is too complex (14 > 10)
   --> src/code_scalpel/security/dependencies/vulnerability_scanner.py:702:9
    |
700 |         )
701 |
702 |     def _parse_vulnerability(
    |         ^^^^^^^^^^^^^^^^^^^^
703 |         self, vuln: dict[str, Any], dep: Dependency
704 |     ) -> VulnerabilityFinding:
    |

C901 `_analyze_with_regex` is too complex (12 > 10)
   --> src/code_scalpel/security/type_safety/type_evaporation_detector.py:595:9
    |
593 |         return ""
594 |
595 |     def _analyze_with_regex(self, code: str, result: TypeEvaporationResult) -> None:
    |         ^^^^^^^^^^^^^^^^^^^
596 |         """Fallback regex-based analysis when tree-sitter is unavailable."""
597 |         lines = code.splitlines()
    |

C901 `analyze_type_evaporation_cross_file` is too complex (17 > 10)
   --> src/code_scalpel/security/type_safety/type_evaporation_detector.py:706:5
    |
706 | def analyze_type_evaporation_cross_file(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
707 |     typescript_code: str,
708 |     python_code: str,
    |

C901 `_collect_import_context` is too complex (12 > 10)
   --> src/code_scalpel/surgery/rename_symbol_refactor.py:147:5
    |
147 | def _collect_import_context(
    |     ^^^^^^^^^^^^^^^^^^^^^^^
148 |     tree: ast.AST,
149 |     *,
    |

C901 `_collect_reference_edits` is too complex (47 > 10)
   --> src/code_scalpel/surgery/rename_symbol_refactor.py:201:5
    |
201 | def _collect_reference_edits(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^
202 |     code: str,
203 |     *,
    |

C901 `_ensure_parsed` is too complex (17 > 10)
   --> src/code_scalpel/surgery/surgical_extractor.py:643:9
    |
641 |         return cls(code, file_path=resolved_path)
642 |
643 |     def _ensure_parsed(self) -> None:
    |         ^^^^^^^^^^^^^^
644 |         """Parse the code if not already done."""
645 |         if self._parsed:
    |

C901 `list_decorators` is too complex (11 > 10)
   --> src/code_scalpel/surgery/surgical_extractor.py:706:9
    |
704 |         return methods
705 |
706 |     def list_decorators(self) -> list[str]:
    |         ^^^^^^^^^^^^^^^
707 |         """
708 |         List all decorator names used in the code.
    |

C901 `find_callers` is too complex (26 > 10)
    --> src/code_scalpel/surgery/surgical_extractor.py:1001:9
     |
 999 |         return result
1000 |
1001 |     def find_callers(self, target_name: str) -> list[tuple[str, str, int]]:
     |         ^^^^^^^^^^^^
1002 |         """
1003 |         Find all functions/methods that call a target function.
     |

C901 `get_function_with_context` is too complex (12 > 10)
    --> src/code_scalpel/surgery/surgical_extractor.py:1103:9
     |
1101 |         return callers
1102 |
1103 |     def get_function_with_context(
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^
1104 |         self, name: str, max_depth: int = 2
1105 |     ) -> ContextualExtraction:
     |

C901 `get_class_with_context` is too complex (12 > 10)
    --> src/code_scalpel/surgery/surgical_extractor.py:1180:9
     |
1178 |         )
1179 |
1180 |     def get_class_with_context(
     |         ^^^^^^^^^^^^^^^^^^^^^^
1181 |         self, name: str, max_depth: int = 2
1182 |     ) -> ContextualExtraction:
     |

C901 `get_method_with_context` is too complex (35 > 10)
    --> src/code_scalpel/surgery/surgical_extractor.py:1248:9
     |
1246 |         )
1247 |
1248 |     def get_method_with_context(
     |         ^^^^^^^^^^^^^^^^^^^^^^^
1249 |         self, class_name: str, method_name: str, max_depth: int = 2
1250 |     ) -> ContextualExtraction:
     |

C901 `gather_deps` is too complex (13 > 10)
    --> src/code_scalpel/surgery/surgical_extractor.py:1324:13
     |
1322 |             return self_calls
1323 |
1324 |         def gather_deps(
     |             ^^^^^^^^^^^
1325 |             deps: list[str], depth: int, from_node: ast.AST | None = None
1326 |         ) -> None:
     |

C901 `resolve_cross_file_dependencies` is too complex (25 > 10)
    --> src/code_scalpel/surgery/surgical_extractor.py:1408:9
     |
1406 |         )
1407 |
1408 |     def resolve_cross_file_dependencies(
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
1409 |         self,
1410 |         target_name: str,
     |

C901 `resolve_symbol` is too complex (13 > 10)
    --> src/code_scalpel/surgery/surgical_extractor.py:1495:13
     |
1493 |             return extractor_cache[path]
1494 |
1495 |         def resolve_symbol(
     |             ^^^^^^^^^^^^^^
1496 |             symbol_name: str,
1497 |             module_info: tuple[str | None, str, str],
     |

C901 `_find_dependencies` is too complex (31 > 10)
    --> src/code_scalpel/surgery/surgical_extractor.py:1762:9
     |
1760 |             raise
1761 |
1762 |     def _find_dependencies(self, node: ast.AST) -> list[str]:
     |         ^^^^^^^^^^^^^^^^^^
1763 |         """
1764 |         Find names that this node depends on.
     |

C901 `_find_required_imports` is too complex (12 > 10)
    --> src/code_scalpel/surgery/surgical_extractor.py:1898:9
     |
1896 |         return [d for d in deps if d not in builtins]
1897 |
1898 |     def _find_required_imports(self, node: ast.AST) -> list[str]:
     |         ^^^^^^^^^^^^^^^^^^^^^^
1899 |         """
1900 |         Find which imports are needed for this node.
     |

C901 `promote_variables` is too complex (18 > 10)
    --> src/code_scalpel/surgery/surgical_extractor.py:2035:5
     |
2035 | def promote_variables(code: str, function_name: str) -> VariablePromotionResult:
     |     ^^^^^^^^^^^^^^^^^
2036 |     """
2037 |     Analyze a function and promote local variables to parameters.
     |

C901 `extract_as_microservice` is too complex (22 > 10)
    --> src/code_scalpel/surgery/surgical_extractor.py:2242:5
     |
2242 | def extract_as_microservice(
     |     ^^^^^^^^^^^^^^^^^^^^^^^
2243 |     code: str, function_name: str, host: str = "0.0.0.0", port: int = 8000
2244 | ) -> MicroserviceExtractionResult:
     |

C901 `detect_closure_variables` is too complex (41 > 10)
    --> src/code_scalpel/surgery/surgical_extractor.py:2673:5
     |
2673 | def detect_closure_variables(code: str, function_name: str) -> ClosureAnalysisResult:
     |     ^^^^^^^^^^^^^^^^^^^^^^^^
2674 |     """
2675 |     Detect variables captured from outer scopes (closures).
     |

C901 `suggest_dependency_injection` is too complex (21 > 10)
    --> src/code_scalpel/surgery/surgical_extractor.py:2905:5
     |
2905 | def suggest_dependency_injection(
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
2906 |     code: str, function_name: str
2907 | ) -> DependencyInjectionResult:
     |

C901 `resolve_organization_wide` is too complex (19 > 10)
    --> src/code_scalpel/surgery/surgical_extractor.py:3137:5
     |
3137 | def resolve_organization_wide(
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^
3138 |     code: str,
3139 |     function_name: str,
     |

C901 `extract_with_custom_pattern` is too complex (32 > 10)
    --> src/code_scalpel/surgery/surgical_extractor.py:3331:5
     |
3331 | def extract_with_custom_pattern(
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
3332 |     pattern: str,
3333 |     pattern_type: str = "regex",
     |

C901 `detect_service_boundaries` is too complex (21 > 10)
    --> src/code_scalpel/surgery/surgical_extractor.py:3556:5
     |
3556 | def detect_service_boundaries(
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^
3557 |     project_root: str | None = None,
3558 |     min_isolation_score: float = 0.6,
     |

C901 `_collect_same_file_references` is too complex (15 > 10)
   --> src/code_scalpel/surgery/surgical_patcher.py:216:5
    |
216 | def _collect_same_file_references(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
217 |     code: str,
218 |     target_type: str,
    |

C901 `insert_method` is too complex (11 > 10)
   --> src/code_scalpel/surgery/surgical_patcher.py:935:9
    |
933 |         )
934 |
935 |     def insert_method(self, class_name: str, new_code: str) -> PatchResult:
    |         ^^^^^^^^^^^^^
936 |         """
937 |         Insert a new method into an existing class.
    |

C901 `rename_symbol` is too complex (11 > 10)
    --> src/code_scalpel/surgery/surgical_patcher.py:1047:9
     |
1045 |         )
1046 |
1047 |     def rename_symbol(
     |         ^^^^^^^^^^^^^
1048 |         self, target_type: str, target_name: str, new_name: str
1049 |     ) -> PatchResult:
     |

C901 `find_matching_brace` is too complex (22 > 10)
    --> src/code_scalpel/surgery/surgical_patcher.py:1359:9
     |
1357 |         self.length = len(code)
1358 |
1359 |     def find_matching_brace(self, start_pos: int) -> int:
     |         ^^^^^^^^^^^^^^^^^^^
1360 |         """
1361 |         Find the position of the closing brace matching the opening brace at start_pos.
     |

C901 `_find_standalone_functions` is too complex (12 > 10)
    --> src/code_scalpel/surgery/surgical_patcher.py:1677:9
     |
1675 |         return methods
1676 |
1677 |     def _find_standalone_functions(self) -> list[PolyglotSymbolLocation]:
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^
1678 |         """Find standalone function declarations."""
1679 |         functions: list[PolyglotSymbolLocation] = []
     |

C901 `_find_methods_in_class` is too complex (11 > 10)
    --> src/code_scalpel/surgery/surgical_patcher.py:1925:9
     |
1923 |         return symbols
1924 |
1925 |     def _find_methods_in_class(
     |         ^^^^^^^^^^^^^^^^^^^^^^
1926 |         self, class_name: str, class_start: int, class_end: int
1927 |     ) -> list[PolyglotSymbolLocation]:
     |

C901 `rename_symbol` is too complex (12 > 10)
    --> src/code_scalpel/surgery/surgical_patcher.py:2483:9
     |
2481 |         return backup_path
2482 |
2483 |     def rename_symbol(
     |         ^^^^^^^^^^^^^
2484 |         self, target_type: str, target_name: str, new_name: str
2485 |     ) -> PatchResult:
     |

C901 `detect_language` is too complex (17 > 10)
   --> src/code_scalpel/surgery/unified_extractor.py:507:5
    |
507 | def detect_language(
    |     ^^^^^^^^^^^^^^^
508 |     file_path: Optional[str] = None, code: Optional[str] = None
509 | ) -> Language:
    |

C901 `_list_symbols_python` is too complex (15 > 10)
   --> src/code_scalpel/surgery/unified_extractor.py:737:9
    |
735 |             return []  # Not yet implemented for other languages
736 |
737 |     def _list_symbols_python(
    |         ^^^^^^^^^^^^^^^^^^^^
738 |         self, symbol_types: Optional[list[str]]
739 |     ) -> list[SymbolInfo]:
    |

C901 `_extract_signatures_python` is too complex (22 > 10)
    --> src/code_scalpel/surgery/unified_extractor.py:1130:9
     |
1128 |         return []
1129 |
1130 |     def _extract_signatures_python(
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^
1131 |         self, symbol_types: Optional[list[str]]
1132 |     ) -> list[SignatureInfo]:
     |

C901 `_get_params` is too complex (11 > 10)
    --> src/code_scalpel/surgery/unified_extractor.py:1206:17
     |
1204 |                 )
1205 |
1206 |             def _get_params(self, args: ast.arguments) -> list[str]:
     |                 ^^^^^^^^^^^
1207 |                 """Extract parameter strings with type hints."""
1208 |                 params = []
     |

C901 `_get_docstring_python` is too complex (13 > 10)
    --> src/code_scalpel/surgery/unified_extractor.py:1278:9
     |
1276 |         return None
1277 |
1278 |     def _get_docstring_python(
     |         ^^^^^^^^^^^^^^^^^^^^^
1279 |         self, target_type: str, target_name: str
1280 |     ) -> Optional[str]:
     |

C901 `_analyze_uncached` is too complex (16 > 10)
   --> src/code_scalpel/symbolic_execution_tools/engine.py:384:9
    |
382 |         return result
383 |
384 |     def _analyze_uncached(self, code: str, language: str) -> AnalysisResult:
    |         ^^^^^^^^^^^^^^^^^
385 |         """Perform symbolic analysis without caching (internal method)."""
386 |         # Fresh components for this analysis
    |

C901 `_execute_statement` is too complex (11 > 10)
   --> src/code_scalpel/symbolic_execution_tools/ir_interpreter.py:809:9
    |
807 |         return current_states
808 |
809 |     def _execute_statement(
    |         ^^^^^^^^^^^^^^^^^^
810 |         self,
811 |         stmt: IRNode,
    |

C901 `_eval_compare` is too complex (12 > 10)
    --> src/code_scalpel/symbolic_execution_tools/ir_interpreter.py:1237:9
     |
1235 |             return None
1236 |
1237 |     def _eval_compare(self, expr: IRCompare, state: SymbolicState) -> Optional[BoolRef]:
     |         ^^^^^^^^^^^^^
1238 |         """Evaluate a comparison."""
1239 |         left = self._eval_expr(expr.left, state)
     |

C901 `_combine_types_for_binop` is too complex (24 > 10)
   --> src/code_scalpel/symbolic_execution_tools/type_inference.py:305:9
    |
303 |         return self._combine_types_for_binop(left_type, node.op, right_type)
304 |
305 |     def _combine_types_for_binop(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^
306 |         self, left: InferredType, op: ast.operator, right: InferredType
307 |     ) -> InferredType:
    |

C901 `resolve_file_path` is too complex (14 > 10)
  --> src/code_scalpel/utilities/path_resolution.py:30:5
   |
30 | def resolve_file_path(
   |     ^^^^^^^^^^^^^^^^^
31 |     file_path: str,
32 |     workspace_root: Optional[str] = None,
   |

Found 263 errors.
