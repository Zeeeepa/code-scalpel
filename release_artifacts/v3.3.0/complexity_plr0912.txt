PLR0912 Too many branches (13 > 12)
   --> src/code_scalpel/analysis/code_analyzer.py:427:9
    |
425 |         return "python"
426 |
427 |     def _parse_code(
    |         ^^^^^^^^^^^
428 |         self,
429 |         code: str,
    |

PLR0912 Too many branches (13 > 12)
   --> src/code_scalpel/analysis/generated_code.py:109:9
    |
107 |         self.root = Path(project_root)
108 |
109 |     def detect(
    |         ^^^^^^
110 |         self, check_headers: bool = True, max_files: int = 10000
111 |     ) -> GeneratedCodeResult:
    |

PLR0912 Too many branches (24 > 12)
   --> src/code_scalpel/analysis/project_crawler.py:802:9
    |
800 |         return False
801 |
802 |     def crawl(self) -> CrawlResult:
    |         ^^^^^
803 |         """
804 |         Crawl the project and analyze all Python files.
    |

PLR0912 Too many branches (15 > 12)
   --> src/code_scalpel/analysis/smart_crawl.py:100:9
    |
 98 |         self._project_type: Optional[ProjectTypeInfo] = None
 99 |
100 |     def detect_project_type(self) -> ProjectTypeInfo:
    |         ^^^^^^^^^^^^^^^^^^^
101 |         """Detect the project type based on marker files."""
102 |         if self._project_type is not None:
    |

PLR0912 Too many branches (41 > 12)
   --> src/code_scalpel/ast_tools/call_graph.py:313:9
    |
311 |                     yield Path(root) / file
312 |
313 |     def _analyze_definitions_js_ts(self, file_path: Path, rel_path: str) -> None:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^
314 |         """Extract JS/TS definitions and import/export metadata.
    |

PLR0912 Too many branches (18 > 12)
   --> src/code_scalpel/ast_tools/call_graph.py:530:9
    |
528 |         return None
529 |
530 |     def _analyze_calls_js_ts(
    |         ^^^^^^^^^^^^^^^^^^^^
531 |         self,
532 |         file_path: Path,
    |

PLR0912 Too many branches (40 > 12)
    --> src/code_scalpel/ast_tools/call_graph.py:1092:9
     |
1090 |     # [20251213_FEATURE] v1.5.0 - Enhanced call graph methods
1091 |
1092 |     def build_with_details(
     |         ^^^^^^^^^^^^^^^^^^
1093 |         self,
1094 |         entry_point: Optional[str] = None,
     |

PLR0912 Too many branches (14 > 12)
    --> src/code_scalpel/ast_tools/call_graph.py:1209:13
     |
1207 |             tree_sitter_available = False
1208 |
1209 |         def _add_js_nodes_esprima(file_path: Path, rel_path: str) -> None:
     |             ^^^^^^^^^^^^^^^^^^^^^
1210 |             try:
1211 |                 import esprima  # type: ignore[import-untyped]
     |

PLR0912 Too many branches (20 > 12)
    --> src/code_scalpel/ast_tools/call_graph.py:1425:9
     |
1423 |         )
1424 |
1425 |     def _is_entry_point(
     |         ^^^^^^^^^^^^^^^
1426 |         self, func_node: ast.FunctionDef | ast.AsyncFunctionDef, tree: ast.AST
1427 |     ) -> bool:
     |

PLR0912 Too many branches (15 > 12)
    --> src/code_scalpel/ast_tools/call_graph.py:1690:9
     |
1688 |         return "\n".join(lines)
1689 |
1690 |     def detect_circular_imports(self) -> List[List[str]]:
     |         ^^^^^^^^^^^^^^^^^^^^^^^
1691 |         """
1692 |         Detect circular import cycles in the project.
     |

PLR0912 Too many branches (13 > 12)
   --> src/code_scalpel/ast_tools/cross_file_extractor.py:784:9
    |
782 |         return set(dir(builtins))
783 |
784 |     def _gather_dependencies(
    |         ^^^^^^^^^^^^^^^^^^^^
785 |         self,
786 |         target: ExtractedSymbol,
    |

PLR0912 Too many branches (14 > 12)
   --> src/code_scalpel/ast_tools/cross_file_extractor.py:927:9
    |
925 |         return root in stdlib_prefixes
926 |
927 |     def _generate_combined_code(self, result: ExtractionResult) -> None:
    |         ^^^^^^^^^^^^^^^^^^^^^^^
928 |         """
929 |         Generate the combined code output with dependencies first.
    |

PLR0912 Too many branches (13 > 12)
   --> src/code_scalpel/ast_tools/dependency_parser.py:139:9
    |
137 |         return deps
138 |
139 |     def _parse_maven_deps(self) -> List[Dict[str, str]]:
    |         ^^^^^^^^^^^^^^^^^
140 |         deps: List[Dict[str, str]] = []
    |

PLR0912 Too many branches (13 > 12)
   --> src/code_scalpel/ast_tools/import_resolver.py:584:9
    |
582 |                     self._incremental.record_dependency(source_path, target_path)
583 |
584 |     def _extract_imports(
    |         ^^^^^^^^^^^^^^^^
585 |         self, tree: ast.Module, module_name: str, file_path: str
586 |     ) -> None:
    |

PLR0912 Too many branches (14 > 12)
   --> src/code_scalpel/autonomy/mutation_gate.py:420:9
    |
418 |         )
419 |
420 |     def _generate_mutations(self, code: str, language: str) -> List[Mutation]:
    |         ^^^^^^^^^^^^^^^^^^^
421 |         """
422 |         Generate additional mutations for the code.
    |

PLR0912 Too many branches (13 > 12)
   --> src/code_scalpel/cli.py:197:5
    |
197 | def analyze_code(
    |     ^^^^^^^^^^^^
198 |     code: str,
199 |     output_format: str = "text",
    |

PLR0912 Too many branches (13 > 12)
   --> src/code_scalpel/cli.py:409:5
    |
409 | def init_configuration(target_dir: str = ".", force: bool = False) -> int:
    |     ^^^^^^^^^^^^^^^^^^
410 |     """Initialize .code-scalpel configuration directory.
    |

PLR0912 Too many branches (21 > 12)
   --> src/code_scalpel/cli.py:796:5
    |
796 | def main() -> int:
    |     ^^^^
797 |     """Main CLI entry point."""
798 |     from . import __version__
    |

PLR0912 Too many branches (14 > 12)
   --> src/code_scalpel/code_parsers/adapters/javascript_adapter.py:265:9
    |
263 |         self._traverse_ast(ast)
264 |
265 |     def _traverse_ast(self, node: Any, depth: int = 0) -> None:
    |         ^^^^^^^^^^^^^
266 |         """Recursively traverse AST to find functions and classes."""
267 |         if node is None or depth > 100:  # Prevent infinite recursion
    |

PLR0912 Too many branches (16 > 12)
   --> src/code_scalpel/code_parsers/extractor.py:416:9
    |
414 |             )
415 |
416 |     def _extract_from_ir(
    |         ^^^^^^^^^^^^^^^^
417 |         self, target_type: str, target_name: str
418 |     ) -> PolyglotExtractionResult:
    |

PLR0912 Too many branches (14 > 12)
   --> src/code_scalpel/code_parsers/java_parsers/java_parser_treesitter.py:699:9
    |
697 |         )
698 |
699 |     def _extract_class(self, node, is_inner: bool = False) -> JavaClass:
    |         ^^^^^^^^^^^^^^
700 |         """Extract class information from a class declaration node."""
701 |         name_node = node.child_by_field_name("name")
    |

PLR0912 Too many branches (25 > 12)
   --> src/code_scalpel/code_parsers/java_parsers/java_parser_treesitter.py:872:9
    |
870 |         )
871 |
872 |     def _extract_module_directive(self, node) -> Optional[JavaModuleDirective]:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^
873 |         """Extract a single module directive."""
874 |         directive_type = None
    |

PLR0912 Too many branches (14 > 12)
    --> src/code_scalpel/code_parsers/java_parsers/java_parser_treesitter.py:1036:9
     |
1034 |         return result
1035 |
1036 |     def parse_detailed(self, code: str) -> JavaParseResult:
     |         ^^^^^^^^^^^^^^
1037 |         """
1038 |         Parse Java source code and return detailed structural information.
     |

PLR0912 Too many branches (25 > 12)
   --> src/code_scalpel/code_parsers/java_parsers/java_parsers_javalang.py:645:9
    |
643 |         )
644 |
645 |     def _collect_halstead_tokens(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^
646 |         self, node: JavaNode, operators: dict[str, int], operands: dict[str, int]
647 |     ) -> None:
    |

PLR0912 Too many branches (15 > 12)
   --> src/code_scalpel/code_parsers/java_parsers/java_parsers_javalang.py:877:9
    |
875 |         return patterns
876 |
877 |     def _check_singleton_pattern(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^
878 |         self, class_node: JavaNode
879 |     ) -> Optional[DesignPatternMatch]:
    |

PLR0912 Too many branches (16 > 12)
    --> src/code_scalpel/code_parsers/java_parsers/java_parsers_javalang.py:1431:9
     |
1429 |     # ==================== TRY-CATCH PATTERN EXTRACTION ====================
1430 |
1431 |     def _extract_try_catch_patterns(
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^
1432 |         self, ast: JavaCompilationUnit
1433 |     ) -> list[TryCatchPattern]:
     |

PLR0912 Too many branches (21 > 12)
   --> src/code_scalpel/code_parsers/javascript_parsers/javascript_parsers_esprima.py:658:9
    |
656 |         )
657 |
658 |     def _collect_halstead(
    |         ^^^^^^^^^^^^^^^^^
659 |         self, node: JSNode, operators: dict[str, int], operands: dict[str, int]
660 |     ) -> None:
    |

PLR0912 Too many branches (24 > 12)
   --> src/code_scalpel/code_parsers/javascript_parsers/javascript_parsers_esprima.py:800:13
    |
798 |         issues: list[SecurityIssue] = []
799 |
800 |         def visit(node: JSNode) -> None:
    |             ^^^^^
801 |             # Check for eval
802 |             if isinstance(node, esprima.nodes.CallExpression):
    |

PLR0912 Too many branches (18 > 12)
   --> src/code_scalpel/code_parsers/javascript_parsers/javascript_parsers_esprima.py:982:13
    |
980 |         functions: list[FunctionInfo] = []
981 |
982 |         def visit(node: JSNode, depth: int = 0) -> None:
    |             ^^^^^
983 |             if isinstance(
984 |                 node,
    |

PLR0912 Too many branches (14 > 12)
    --> src/code_scalpel/code_parsers/javascript_parsers/javascript_parsers_esprima.py:1156:13
     |
1154 |         exports: list[ExportInfo] = []
1155 |
1156 |         def visit(node: JSNode) -> None:
     |             ^^^^^
1157 |             if isinstance(node, esprima.nodes.ExportDefaultDeclaration):
1158 |                 name = "<default>"
     |

PLR0912 Too many branches (14 > 12)
   --> src/code_scalpel/code_parsers/javascript_parsers/javascript_parsers_flow.py:457:9
    |
455 |         return params
456 |
457 |     def _determine_type_kind(self, type_value: str) -> FlowTypeKind:
    |         ^^^^^^^^^^^^^^^^^^^^
458 |         """Determine the kind of a Flow type."""
459 |         type_value = type_value.strip()
    |

PLR0912 Too many branches (15 > 12)
   --> src/code_scalpel/code_parsers/javascript_parsers/javascript_parsers_flow.py:610:9
    |
608 |             raise TimeoutError("Flow coverage timed out")
609 |
610 |     def parse_config(self, config_path: str = ".flowconfig") -> FlowConfig:
    |         ^^^^^^^^^^^^
611 |         """
612 |         Parse a .flowconfig file.
    |

PLR0912 Too many branches (15 > 12)
   --> src/code_scalpel/code_parsers/javascript_parsers/javascript_parsers_treesitter.py:471:13
    |
469 |         current_class: Optional[str] = None
470 |
471 |         def visit(
    |             ^^^^^
472 |             node: TreeSitterNode, is_exported: bool = False, is_default: bool = False
473 |         ) -> None:
    |

PLR0912 Too many branches (17 > 12)
   --> src/code_scalpel/code_parsers/javascript_parsers/javascript_parsers_treesitter.py:672:13
    |
670 |         imports: list[ImportStatement] = []
671 |
672 |         def visit(node: TreeSitterNode) -> None:
    |             ^^^^^
673 |             if node.type == "import_statement":
674 |                 source = node.child_by_field("source")
    |

PLR0912 Too many branches (19 > 12)
   --> src/code_scalpel/code_parsers/javascript_parsers/javascript_parsers_treesitter.py:793:13
    |
791 |         components: list[JSXComponent] = []
792 |
793 |         def visit(node: TreeSitterNode) -> None:
    |             ^^^^^
794 |             if node.type in ("jsx_element", "jsx_self_closing_element"):
795 |                 is_self_closing = node.type == "jsx_self_closing_element"
    |

PLR0912 Too many branches (13 > 12)
   --> src/code_scalpel/code_parsers/language_detection.py:477:5
    |
477 | def detect_language_confidence(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^
478 |     filepath: Optional[str] = None,
479 |     code: Optional[str] = None,
    |

PLR0912 Too many branches (15 > 12)
   --> src/code_scalpel/code_parsers/python_parsers/__init__.py:365:5
    |
363 | # Lazy Loading Implementation
364 | # =============================================================================
365 | def __getattr__(name: str):
    |     ^^^^^^^^^^^
366 |     """
367 |     Lazy load parser classes on first access.
    |

PLR0912 Too many branches (17 > 12)
    --> src/code_scalpel/code_parsers/python_parsers/python_parsers_ast.py:1602:9
     |
1600 |         return analyzer.analyze()
1601 |
1602 |     def extract_type_annotations(
     |         ^^^^^^^^^^^^^^^^^^^^^^^^
1603 |         self, module: PythonModule
1604 |     ) -> dict[str, TypeAnnotation]:
     |

PLR0912 Too many branches (13 > 12)
    --> src/code_scalpel/code_parsers/python_parsers/python_parsers_ast.py:2007:9
     |
2005 |         self.scope_stack.pop()
2006 |
2007 |     def visit_ClassDef(self, node: ast.ClassDef) -> None:
     |         ^^^^^^^^^^^^^^
2008 |         """Visit a class definition."""
2009 |         bases = [ast.unparse(base) for base in node.bases]
     |

PLR0912 Too many branches (16 > 12)
    --> src/code_scalpel/code_parsers/python_parsers/python_parsers_ast.py:2948:9
     |
2946 |         return isinstance(last_stmt, (ast.Return, ast.Raise))
2947 |
2948 |     def _visit_stmt(self, stmt: ast.stmt) -> None:
     |         ^^^^^^^^^^^
2949 |         """Visit a statement and update CFG."""
2950 |         if self.current_block is None:
     |

PLR0912 Too many branches (20 > 12)
    --> src/code_scalpel/code_parsers/python_parsers/python_parsers_ast.py:3124:9
     |
3122 |         self._set_current_block(loop_after)
3123 |
3124 |     def _visit_try(self, stmt: ast.Try) -> None:
     |         ^^^^^^^^^^
3125 |         """Handle try/except/else/finally blocks."""
3126 |         try_block = self._new_block("try_body")
     |

PLR0912 Too many branches (20 > 12)
    --> src/code_scalpel/code_parsers/python_parsers/python_parsers_ast.py:3450:9
     |
3448 |                 self._process_statement(stmt, block)
3449 |
3450 |     def _process_statement(self, stmt: ast.stmt, block: BasicBlock) -> None:
     |         ^^^^^^^^^^^^^^^^^^
3451 |         """Process a statement for definitions and uses."""
3452 |         # First collect uses (before any definitions in this statement)
     |

PLR0912 Too many branches (18 > 12)
    --> src/code_scalpel/code_parsers/python_parsers/python_parsers_ast.py:3740:9
     |
3738 |                 constants[stmt.target.id] = ConstantValue.not_constant()
3739 |
3740 |     def _evaluate_constant(
     |         ^^^^^^^^^^^^^^^^^^
3741 |         self,
3742 |         node: ast.expr,
     |

PLR0912 Too many branches (15 > 12)
    --> src/code_scalpel/code_parsers/python_parsers/python_parsers_ast.py:3849:9
     |
3847 |         return None
3848 |
3849 |     def _compute_available_expressions(self) -> dict[int, set[Expression]]:
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
3850 |         """
3851 |         Compute available expressions using forward data flow analysis.
     |

PLR0912 Too many branches (15 > 12)
    --> src/code_scalpel/code_parsers/python_parsers/python_parsers_ast.py:3922:9
     |
3920 |         return avail_in
3921 |
3922 |     def _compute_very_busy_expressions(self) -> dict[int, set[Expression]]:
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
3923 |         """
3924 |         Compute very busy expressions using backward data flow analysis.
     |

PLR0912 Too many branches (15 > 12)
    --> src/code_scalpel/code_parsers/python_parsers/python_parsers_bandit.py:1317:9
     |
1315 |             return False
1316 |
1317 |     def analyze(
     |         ^^^^^^^
1318 |         self,
1319 |         target: str | Path | list[str | Path],
     |

PLR0912 Too many branches (23 > 12)
    --> src/code_scalpel/code_parsers/python_parsers/python_parsers_code_quality.py:1306:13
     |
1304 |         complexity = 0
1305 |
1306 |         def walk(n: ast.AST, nesting: int = 0) -> None:
     |             ^^^^
1307 |             nonlocal complexity
     |

PLR0912 Too many branches (14 > 12)
    --> src/code_scalpel/code_parsers/python_parsers/python_parsers_flake8.py:1038:9
     |
1036 |         return report
1037 |
1038 |     def analyze_json(
     |         ^^^^^^^^^^^^
1039 |         self,
1040 |         target: str | Path | list[str | Path],
     |

PLR0912 Too many branches (17 > 12)
   --> src/code_scalpel/code_parsers/python_parsers/python_parsers_mypy.py:719:9
    |
718 |     @classmethod
719 |     def _from_ini(cls, path: Path, section: str = "mypy") -> MypyConfig:
    |         ^^^^^^^^^
720 |         """Load configuration from INI file (mypy.ini or setup.cfg)."""
721 |         parser = configparser.ConfigParser()
    |

PLR0912 Too many branches (19 > 12)
   --> src/code_scalpel/code_parsers/python_parsers/python_parsers_mypy.py:792:9
    |
791 |     @classmethod
792 |     def _from_dict(cls, data: dict[str, Any]) -> MypyConfig:
    |         ^^^^^^^^^^
793 |         """Create MypyConfig from a dictionary."""
794 |         config = cls()
    |

PLR0912 Too many branches (16 > 12)
    --> src/code_scalpel/code_parsers/python_parsers/python_parsers_mypy.py:1082:9
     |
1080 |             return False
1081 |
1082 |     def analyze(
     |         ^^^^^^^
1083 |         self,
1084 |         target: str | Path | list[str | Path],
     |

PLR0912 Too many branches (14 > 12)
    --> src/code_scalpel/code_parsers/python_parsers/python_parsers_mypy.py:1174:9
     |
1172 |         return report
1173 |
1174 |     def analyze_json(
     |         ^^^^^^^^^^^^
1175 |         self,
1176 |         target: str | Path | list[str | Path],
     |

PLR0912 Too many branches (19 > 12)
    --> src/code_scalpel/code_parsers/python_parsers/python_parsers_mypy.py:1274:9
     |
1272 |         return report
1273 |
1274 |     def analyze_with_context(
     |         ^^^^^^^^^^^^^^^^^^^^
1275 |         self,
1276 |         target: str | Path | list[str | Path],
     |

PLR0912 Too many branches (13 > 12)
   --> src/code_scalpel/code_parsers/python_parsers/python_parsers_prospector.py:359:9
    |
358 |     @classmethod
359 |     def _from_dict(cls, data: dict[str, Any], name: str) -> ProspectorProfile:
    |         ^^^^^^^^^^
360 |         """Create profile from dictionary."""
361 |         profile = ProspectorProfile(name=name)
    |

PLR0912 Too many branches (17 > 12)
   --> src/code_scalpel/code_parsers/python_parsers/python_parsers_prospector.py:447:5
    |
447 | def merge_profiles(*profiles: ProspectorProfile) -> ProspectorProfile:
    |     ^^^^^^^^^^^^^^
448 |     """
449 |     Merge multiple profiles with later profiles taking priority.
    |

PLR0912 Too many branches (19 > 12)
   --> src/code_scalpel/code_parsers/python_parsers/python_parsers_pylint.py:922:9
    |
921 |     @classmethod
922 |     def _from_ini(cls, path: Path) -> PylintConfig:
    |         ^^^^^^^^^
923 |         """Load configuration from INI file (.pylintrc or setup.cfg)."""
924 |         parser = configparser.ConfigParser()
    |

PLR0912 Too many branches (18 > 12)
   --> src/code_scalpel/code_parsers/python_parsers/python_parsers_pylint.py:982:9
    |
981 |     @classmethod
982 |     def _from_dict(cls, data: dict[str, Any]) -> PylintConfig:
    |         ^^^^^^^^^^
983 |         """Create PylintConfig from a dictionary (from pyproject.toml)."""
984 |         config = cls()
    |

PLR0912 Too many branches (18 > 12)
   --> src/code_scalpel/code_parsers/python_parsers/python_parsers_ruff.py:518:9
    |
517 |     @classmethod
518 |     def _from_dict(cls, data: dict[str, Any]) -> RuffConfig:
    |         ^^^^^^^^^^
519 |         """Create RuffConfig from a dictionary."""
520 |         config = cls()
    |

PLR0912 Too many branches (16 > 12)
    --> src/code_scalpel/code_parsers/python_parsers/python_parsers_ruff.py:1133:5
     |
1133 | def format_violations(
     |     ^^^^^^^^^^^^^^^^^
1134 |     violations: list[RuffViolation],
1135 |     *,
     |

PLR0912 Too many branches (14 > 12)
   --> src/code_scalpel/generators/refactor_simulator.py:211:9
    |
209 |         self.strict_mode = strict_mode
210 |
211 |     def simulate(
    |         ^^^^^^^^
212 |         self,
213 |         original_code: str,
    |

PLR0912 Too many branches (35 > 12)
   --> src/code_scalpel/generators/refactor_simulator.py:580:9
    |
578 |         return None
579 |
580 |     def _check_js_syntax_heuristic(self, code: str, language: str) -> str | None:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^
581 |         """Heuristic-based JavaScript/TypeScript syntax validation.
    |

PLR0912 Too many branches (16 > 12)
    --> src/code_scalpel/generators/refactor_simulator.py:1089:9
     |
1087 |         return self._extract_js_structure_regex(code)
1088 |
1089 |     def _extract_js_symbols_from_tree(self, node, structure: dict[str, set]) -> None:
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
1090 |         """Extract symbols from tree-sitter parse tree.
     |

PLR0912 Too many branches (14 > 12)
    --> src/code_scalpel/generators/refactor_simulator.py:1350:9
     |
1348 |         return round(confidence, 3), factors
1349 |
1350 |     def _analyze_test_impact(
     |         ^^^^^^^^^^^^^^^^^^^^
1351 |         self,
1352 |         original_code: str,
     |

PLR0912 Too many branches (15 > 12)
    --> src/code_scalpel/generators/refactor_simulator.py:1778:9
     |
1776 |         return type_errors
1777 |
1778 |     def _predict_regression_impact(
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^
1779 |         self, original_code: str, new_code: str, project_root: str | None = None
1780 |     ) -> dict[str, Any]:
     |

PLR0912 Too many branches (14 > 12)
   --> src/code_scalpel/generators/test_generator.py:635:9
    |
633 |         )
634 |
635 |     def _parse_crash_log(
    |         ^^^^^^^^^^^^^^^^
636 |         self, crash_log: str, function_name: str, language: str
637 |     ) -> dict[str, Any]:
    |

PLR0912 Too many branches (15 > 12)
   --> src/code_scalpel/generators/test_generator.py:894:9
    |
892 |         return 1 if should_satisfy else -1
893 |
894 |     def _extract_test_cases(
    |         ^^^^^^^^^^^^^^^^^^^
895 |         self,
896 |         symbolic_result: dict[str, Any],
    |

PLR0912 Too many branches (21 > 12)
    --> src/code_scalpel/generators/test_generator.py:1043:13
     |
1041 |             return None
1042 |
1043 |         def eval_expr(expr: ast.AST) -> Any:
     |             ^^^^^^^^^
1044 |             if isinstance(expr, ast.Constant):
1045 |                 return expr.value
     |

PLR0912 Too many branches (18 > 12)
    --> src/code_scalpel/generators/test_generator.py:1152:9
     |
1150 |         return {}
1151 |
1152 |     def _to_python_value(self, value: Any, expected_type: str | None = None) -> Any:
     |         ^^^^^^^^^^^^^^^^
1153 |         """Convert Z3 or other symbolic values to Python natives.
     |

PLR0912 Too many branches (27 > 12)
    --> src/code_scalpel/generators/test_generator.py:1301:9
     |
1299 |         return None
1300 |
1301 |     def _infer_expected_result(
     |         ^^^^^^^^^^^^^^^^^^^^^^
1302 |         self, conditions: list[str], return_map: dict[str, Any], inputs: dict[str, Any]
1303 |     ) -> Any:
     |

PLR0912 Too many branches (16 > 12)
   --> src/code_scalpel/graph/graph_query.py:442:9
    |
440 |         return paths
441 |
442 |     def _bfs_paths(
    |         ^^^^^^^^^^
443 |         self,
444 |         start_id: str,
    |

PLR0912 Too many branches (34 > 12)
   --> src/code_scalpel/graph/path_constraints.py:263:9
    |
261 |         return paths
262 |
263 |     def _evaluate_path(
    |         ^^^^^^^^^^^^^^
264 |         self,
265 |         path_node_ids: List[str],
    |

PLR0912 Too many branches (13 > 12)
   --> src/code_scalpel/graph/traversal_rules.py:482:9
    |
480 |         return neighbors
481 |
482 |     def find_paths_with_rules(
    |         ^^^^^^^^^^^^^^^^^^^^^
483 |         self,
484 |         start_id: str,
    |

PLR0912 Too many branches (16 > 12)
   --> src/code_scalpel/graph_engine/graph.py:351:9
    |
350 |     # [20251216_FEATURE] v2.5.0 - Graph Neighborhood View (k-hop subgraph extraction)
351 |     def get_neighborhood(
    |         ^^^^^^^^^^^^^^^^
352 |         self,
353 |         center_node_id: str,
    |

PLR0912 Too many branches (26 > 12)
   --> src/code_scalpel/integrations/protocol_analyzers/kafka/taint_tracker.py:639:17
    |
637 |                 self._handle_function(node)
638 |
639 |             def visit_Call(self, node: ast.Call):
    |                 ^^^^^^^^^^
640 |                 # Check for producer.send() or producer.produce()
641 |                 if isinstance(node.func, ast.Attribute):
    |

PLR0912 Too many branches (15 > 12)
   --> src/code_scalpel/ir/normalizers/java_normalizer.py:187:9
    |
185 |         )
186 |
187 |     def visit_class_declaration(self, node: Any) -> IRClassDef:
    |         ^^^^^^^^^^^^^^^^^^^^^^^
188 |         """
189 |         class MyClass { ... }
    |

PLR0912 Too many branches (20 > 12)
   --> src/code_scalpel/ir/normalizers/java_normalizer.py:761:9
    |
759 |         return self._normalize_switch(node)
760 |
761 |     def _normalize_switch(self, node: Any) -> IRSwitch:
    |         ^^^^^^^^^^^^^^^^^
762 |         """Internal switch normalization."""
763 |         discriminant = None
    |

PLR0912 Too many branches (25 > 12)
  --> src/code_scalpel/licensing/authorization.py:25:5
   |
25 | def compute_effective_tier_for_startup(
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
26 |     *,
27 |     requested_tier: str | None,
   |

PLR0912 Too many branches (13 > 12)
  --> src/code_scalpel/licensing/jwt_generator.py:97:5
   |
97 | def generate_license(
   |     ^^^^^^^^^^^^^^^^
98 |     tier: str,
99 |     customer_id: str,
   |

PLR0912 Too many branches (13 > 12)
   --> src/code_scalpel/licensing/jwt_validator.py:473:9
    |
471 |         return None
472 |
473 |     def _revocation_error_if_revoked(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
474 |         self,
475 |         jti: str,
    |

PLR0912 Too many branches (22 > 12)
   --> src/code_scalpel/licensing/jwt_validator.py:559:9
    |
557 |             return "License revocation list invalid"
558 |
559 |     def validate_token(self, token: str) -> JWTLicenseData:
    |         ^^^^^^^^^^^^^^
560 |         """
561 |         Validate a JWT license token.
    |

PLR0912 Too many branches (16 > 12)
   --> src/code_scalpel/mcp/path_resolver.py:297:9
    |
295 |             raise FileNotFoundError(self._format_error_message(path, result))
296 |
297 |     def _attempt_resolution(
    |         ^^^^^^^^^^^^^^^^^^^
298 |         self, path: str, project_root: Optional[str]
299 |     ) -> PathResolutionResult:
    |

PLR0912 Too many branches (28 > 12)
   --> src/code_scalpel/mcp/server.py:352:5
    |
352 | def _evaluate_change_budget_for_write_tool(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
353 |     *,
354 |     tool_id: str,
    |

PLR0912 Too many branches (24 > 12)
   --> src/code_scalpel/mcp/server.py:678:5
    |
678 | def _maybe_enforce_governance_before_tool(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
679 |     *,
680 |     tool_id: str,
    |

PLR0912 Too many branches (20 > 12)
    --> src/code_scalpel/mcp/server.py:2441:15
     |
2439 |     original_run = tool.run
2440 |
2441 |     async def _enveloped_run(
     |               ^^^^^^^^^^^^^^
2442 |         arguments: dict[str, Any], context: Any = None, convert_result: bool = False
2443 |     ) -> dict[str, Any]:
     |

PLR0912 Too many branches (18 > 12)
    --> src/code_scalpel/mcp/server.py:3046:13
     |
3044 |         imports = []
3045 |
3046 |         def walk_tree(node, depth=0):
     |             ^^^^^^^^^
3047 |             """Walk tree-sitter tree to extract structure."""
3048 |             node_type = node.type
     |

PLR0912 Too many branches (16 > 12)
    --> src/code_scalpel/mcp/server.py:3263:5
     |
3263 | def _detect_dead_code_hints_python(tree: ast.AST, code: str) -> list[str]:
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
3264 |     """Best-effort dead code hints for Python.
     |

PLR0912 Too many branches (60 > 12)
    --> src/code_scalpel/mcp/server.py:3510:5
     |
3510 | def _analyze_code_sync(
     |     ^^^^^^^^^^^^^^^^^^
3511 |     code: str, language: str = "auto", file_path: str | None = None
3512 | ) -> AnalysisResult:
     |

PLR0912 Too many branches (38 > 12)
    --> src/code_scalpel/mcp/server.py:3962:5
     |
3962 | def _security_scan_sync(
     |     ^^^^^^^^^^^^^^^^^^^
3963 |     code: Optional[str] = None,
3964 |     file_path: Optional[str] = None,
     |

PLR0912 Too many branches (34 > 12)
    --> src/code_scalpel/mcp/server.py:4974:5
     |
4974 | def _unified_sink_detect_sync(
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^
4975 |     code: str,
4976 |     language: str,
     |

PLR0912 Too many branches (20 > 12)
    --> src/code_scalpel/mcp/server.py:6278:5
     |
6278 | def _generate_type_compliance_report(
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
6279 |     vulnerabilities: list[Any],
6280 |     api_contract: dict[str, Any] | None,
     |

PLR0912 Too many branches (35 > 12)
    --> src/code_scalpel/mcp/server.py:7085:5
     |
7085 | def _scan_dependencies_sync(
     |     ^^^^^^^^^^^^^^^^^^^^^^^
7086 |     project_root: str | None = None,
7087 |     path: str | None = None,
     |

PLR0912 Too many branches (14 > 12)
    --> src/code_scalpel/mcp/server.py:7371:5
     |
7371 | def _extract_severity(vuln: dict[str, Any]) -> str:
     |     ^^^^^^^^^^^^^^^^^
7372 |     """Extract severity from OSV vulnerability data.
     |

PLR0912 Too many branches (14 > 12)
    --> src/code_scalpel/mcp/server.py:7733:5
     |
7733 | def _detect_requested_constraint_types(code: str) -> set[str]:
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
7734 |     """Best-effort extraction of constraint types implied by code.
     |

PLR0912 Too many branches (29 > 12)
    --> src/code_scalpel/mcp/server.py:8021:5
     |
8021 | def _symbolic_execute_sync(
     |     ^^^^^^^^^^^^^^^^^^^^^^
8022 |     code: str,
8023 |     max_paths: int | None = None,
     |

PLR0912 Too many branches (16 > 12)
    --> src/code_scalpel/mcp/server.py:8299:5
     |
8299 | def _generate_tests_sync(
     |     ^^^^^^^^^^^^^^^^^^^^
8300 |     code: str | None = None,
8301 |     file_path: str | None = None,
     |

PLR0912 Too many branches (21 > 12)
    --> src/code_scalpel/mcp/server.py:8881:5
     |
8881 | def _crawl_project_discovery(
     |     ^^^^^^^^^^^^^^^^^^^^^^^^
8882 |     root_path: str,
8883 |     exclude_dirs: list[str] | None = None,
     |

PLR0912 Too many branches (93 > 12)
    --> src/code_scalpel/mcp/server.py:9111:5
     |
9111 | def _crawl_project_sync(
     |     ^^^^^^^^^^^^^^^^^^^
9112 |     root_path: str,
9113 |     exclude_dirs: list[str] | None = None,
     |

PLR0912 Too many branches (44 > 12)
    --> src/code_scalpel/mcp/server.py:9926:11
     |
9925 | @mcp.tool()
9926 | async def extract_code(
     |           ^^^^^^^^^^^^
9927 |     target_type: str,
9928 |     target_name: str,
     |

PLR0912 Too many branches (14 > 12)
     --> src/code_scalpel/mcp/server.py:10627:11
      |
10627 | async def _update_cross_file_references(
      |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
10628 |     modified_file: str, target_type: str, target_name: str, new_code: str
10629 | ) -> dict[str, Any]:
      |

PLR0912 Too many branches (65 > 12)
     --> src/code_scalpel/mcp/server.py:10989:11
      |
10988 | @mcp.tool()
10989 | async def update_symbol(
      |           ^^^^^^^^^^^^^
10990 |     file_path: str,
10991 |     target_type: str,
      |

PLR0912 Too many branches (13 > 12)
     --> src/code_scalpel/mcp/server.py:12066:11
      |
12065 | @mcp.tool()
12066 | async def crawl_project(
      |           ^^^^^^^^^^^^^
12067 |     root_path: str | None = None,
12068 |     exclude_dirs: list[str] | None = None,
      |

PLR0912 Too many branches (56 > 12)
     --> src/code_scalpel/mcp/server.py:13521:5
      |
13521 | def _get_file_context_sync(
      |     ^^^^^^^^^^^^^^^^^^^^^^
13522 |     file_path: str, tier: str | None = None, capabilities: dict | None = None
13523 | ) -> FileContextResult:
      |

PLR0912 Too many branches (17 > 12)
     --> src/code_scalpel/mcp/server.py:13857:5
      |
13857 | def _detect_code_smells(
      |     ^^^^^^^^^^^^^^^^^^^
13858 |     tree: ast.Module, code: str, lines: list[str]
13859 | ) -> list[dict[str, Any]]:
      |

PLR0912 Too many branches (126 > 12)
     --> src/code_scalpel/mcp/server.py:14394:5
      |
14394 | def _get_symbol_references_sync(
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
14395 |     symbol_name: str,
14396 |     project_root: str | None = None,
      |

PLR0912 Too many branches (16 > 12)
     --> src/code_scalpel/mcp/server.py:15350:5
      |
15350 | def _get_call_graph_sync(
      |     ^^^^^^^^^^^^^^^^^^^^
15351 |     project_root: str | None,
15352 |     entry_point: str | None,
      |

PLR0912 Too many branches (43 > 12)
     --> src/code_scalpel/mcp/server.py:15867:11
      |
15866 | @mcp.tool()
15867 | async def get_graph_neighborhood(
      |           ^^^^^^^^^^^^^^^^^^^^^^
15868 |     center_node_id: str,
15869 |     k: int = 2,
      |

PLR0912 Too many branches (102 > 12)
     --> src/code_scalpel/mcp/server.py:16561:5
      |
16561 | def _get_project_map_sync(
      |     ^^^^^^^^^^^^^^^^^^^^^
16562 |     project_root: str | None,
16563 |     include_complexity: bool,
      |

PLR0912 Too many branches (54 > 12)
     --> src/code_scalpel/mcp/server.py:17728:5
      |
17728 | def _get_cross_file_dependencies_sync(
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
17729 |     target_file: str,
17730 |     target_symbol: str,
      |

PLR0912 Too many branches (21 > 12)
     --> src/code_scalpel/mcp/server.py:18407:5
      |
18407 | def _cross_file_security_scan_sync(
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
18408 |     project_root: str | None,
18409 |     entry_points: list[str] | None,
      |

PLR0912 Too many branches (32 > 12)
     --> src/code_scalpel/mcp/server.py:18875:5
      |
18875 | def _validate_paths_sync(
      |     ^^^^^^^^^^^^^^^^^^^^
18876 |     paths: list[str],
18877 |     project_root: str | None,
      |

PLR0912 Too many branches (17 > 12)
     --> src/code_scalpel/mcp/server.py:19209:5
      |
19209 | def _verify_policy_integrity_sync(
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
19210 |     policy_dir: str | None = None,
19211 |     manifest_source: str = "file",
      |

PLR0912 Too many branches (16 > 12)
     --> src/code_scalpel/mcp/server.py:19693:5
      |
19693 | def run_server(
      |     ^^^^^^^^^^
19694 |     transport: str = "stdio",
19695 |     host: str = "127.0.0.1",
      |

PLR0912 Too many branches (13 > 12)
   --> src/code_scalpel/pdg_tools/builder.py:375:9
    |
373 |         self.exception_deps.pop()
374 |
375 |     def visit_Assign(self, node: ast.Assign):
    |         ^^^^^^^^^^^^
376 |         """Handle assignment statements."""
377 |         node_id = self._get_node_id("assign")
    |

PLR0912 Too many branches (15 > 12)
  --> src/code_scalpel/policy_engine/code_policy_check/analyzer.py:67:9
   |
65 |     """
66 |
67 |     def __init__(
   |         ^^^^^^^^
68 |         self,
69 |         tier: str = "community",
   |

PLR0912 Too many branches (14 > 12)
   --> src/code_scalpel/policy_engine/code_policy_check/analyzer.py:364:9
    |
362 |         return limits.get(self.tier, {}).get(limit_name)
363 |
364 |     def _check_file(
    |         ^^^^^^^^^^^
365 |         self, file_path: str, rules: list[str] | None
366 |     ) -> tuple[list[PolicyViolation], int]:
    |

PLR0912 Too many branches (13 > 12)
   --> src/code_scalpel/policy_engine/code_policy_check/analyzer.py:509:9
    |
507 |         return violations
508 |
509 |     def _check_eslint(self, file_path: str) -> list[PolicyViolation]:
    |         ^^^^^^^^^^^^^
510 |         """Run ESLint checks for JS/TS (best-effort)."""
511 |         violations: list[PolicyViolation] = []
    |

PLR0912 Too many branches (20 > 12)
   --> src/code_scalpel/policy_engine/policy_engine.py:442:9
    |
441 |     @staticmethod
442 |     def _basic_validate_rego(rule: str, policy_name: str) -> None:
    |         ^^^^^^^^^^^^^^^^^^^^
443 |         if not rule or not isinstance(rule, str):
444 |             raise PolicyError(
    |

PLR0912 Too many branches (13 > 12)
   --> src/code_scalpel/policy_engine/policy_engine.py:569:9
    |
567 |                 )
568 |
569 |     def evaluate(self, operation: Operation) -> PolicyDecision:
    |         ^^^^^^^^
570 |         """
571 |         Evaluate operation against all policies.
    |

PLR0912 Too many branches (16 > 12)
   --> src/code_scalpel/polyglot/extractor.py:413:9
    |
411 |             )
412 |
413 |     def _extract_from_ir(
    |         ^^^^^^^^^^^^^^^^
414 |         self, target_type: str, target_name: str
415 |     ) -> PolyglotExtractionResult:
    |

PLR0912 Too many branches (25 > 12)
   --> src/code_scalpel/quality_assurance/error_scanner.py:306:9
    |
304 |         return sorted(python_files)
305 |
306 |     def _check_files_batch(self, files: list[Path]) -> dict[str, list[CodeError]]:
    |         ^^^^^^^^^^^^^^^^^^
307 |         """
308 |         Check a batch of files for errors using mypy, flake8, pylint, and ruff.
    |

PLR0912 Too many branches (15 > 12)
    --> src/code_scalpel/security/analyzers/cross_file_taint.py:1281:9
     |
1279 |         self.current_var: Optional[str] = None
1280 |
1281 |     def visit_Assign(self, node: ast.Assign) -> None:
     |         ^^^^^^^^^^^^
1282 |         """Track variable assignments."""
1283 |         # Check if RHS is a taint source
     |

PLR0912 Too many branches (22 > 12)
    --> src/code_scalpel/security/analyzers/cross_file_taint.py:1377:9
     |
1375 |         return False
1376 |
1377 |     def visit_Call(self, node: ast.Call) -> None:
     |         ^^^^^^^^^^
1378 |         """Check for dangerous sinks."""
1379 |         callee = self._get_callee_name(node)
     |

PLR0912 Too many branches (13 > 12)
  --> src/code_scalpel/security/analyzers/false_positive_analyzer.py:35:9
   |
33 |         pass
34 |
35 |     def is_test_code(self, code: str, filename: str = "") -> bool:
   |         ^^^^^^^^^^^^
36 |         """
37 |         Detect if code is a test file.
   |

PLR0912 Too many branches (27 > 12)
   --> src/code_scalpel/security/analyzers/security_analyzer.py:393:9
    |
391 |         return result
392 |
393 |     def _analyze_node(self, node: ast.AST, result: SecurityAnalysisResult) -> None:
    |         ^^^^^^^^^^^^^
394 |         """Recursively analyze an AST node."""
    |

PLR0912 Too many branches (15 > 12)
   --> src/code_scalpel/security/analyzers/security_analyzer.py:589:9
    |
587 |             parts.append(node)
588 |
589 |     def _analyze_assignment(self, node: ast.Assign) -> None:
    |         ^^^^^^^^^^^^^^^^^^^
590 |         """Analyze an assignment for taint propagation."""
591 |         # Get target name(s)
    |

PLR0912 Too many branches (23 > 12)
   --> src/code_scalpel/security/analyzers/security_analyzer.py:677:9
    |
675 |         return None
676 |
677 |     def _analyze_call(self, node: ast.Call, location: Tuple[int, int]) -> None:
    |         ^^^^^^^^^^^^^
678 |         """Analyze a function call for sink detection."""
679 |         if not self._taint_tracker:
    |

PLR0912 Too many branches (17 > 12)
    --> src/code_scalpel/security/analyzers/taint_tracker.py:2298:5
     |
2298 | def has_input_validation(node: ast.AST) -> bool:
     |     ^^^^^^^^^^^^^^^^^^^^
2299 |     """
2300 |     [20251216_BUGFIX] Accepts both FunctionDef and Lambda nodes for input validation detection.
     |

PLR0912 Too many branches (18 > 12)
    --> src/code_scalpel/security/analyzers/taint_tracker.py:2384:5
     |
2384 | def detect_ssr_vulnerabilities(
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^
2385 |     tree: ast.AST,
2386 |     framework: Optional[str] = None,
     |

PLR0912 Too many branches (15 > 12)
   --> src/code_scalpel/security/dependencies/license_compliance.py:198:9
    |
196 |         return common_licenses.get(package_name.lower(), "UNKNOWN")
197 |
198 |     def _parse_license_text(self, text: str) -> str | None:
    |         ^^^^^^^^^^^^^^^^^^^
199 |         """Parse license from LICENSE file text."""
200 |         text_upper = text.upper()
    |

PLR0912 Too many branches (17 > 12)
   --> src/code_scalpel/security/dependencies/osv_client.py:248:9
    |
246 |         raise OSVError(f"Request failed after {MAX_RETRIES} retries: {last_error}")
247 |
248 |     def _parse_severity(self, vuln_data: Dict[str, Any]) -> str:
    |         ^^^^^^^^^^^^^^^
249 |         """
250 |         Extract severity from OSV vulnerability data.
    |

PLR0912 Too many branches (13 > 12)
   --> src/code_scalpel/security/dependencies/vulnerability_reachability.py:146:9
    |
144 |                 logger.debug(f"Failed to parse {py_file}: {e}")
145 |
146 |     def _extract_calls_and_imports(self, tree: ast.AST, file_path: Path) -> None:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^
147 |         """Extract function calls and imports from AST."""
148 |         module_name = file_path.stem
    |

PLR0912 Too many branches (15 > 12)
   --> src/code_scalpel/security/dependencies/vulnerability_scanner.py:383:9
    |
382 |     @staticmethod
383 |     def parse_pyproject_toml(file_path: Path) -> list[Dependency]:
    |         ^^^^^^^^^^^^^^^^^^^^
384 |         """Parse Python pyproject.toml file (PEP 621 and Poetry formats).
    |

PLR0912 Too many branches (14 > 12)
   --> src/code_scalpel/security/dependencies/vulnerability_scanner.py:702:9
    |
700 |         )
701 |
702 |     def _parse_vulnerability(
    |         ^^^^^^^^^^^^^^^^^^^^
703 |         self, vuln: dict[str, Any], dep: Dependency
704 |     ) -> VulnerabilityFinding:
    |

PLR0912 Too many branches (47 > 12)
   --> src/code_scalpel/surgery/rename_symbol_refactor.py:201:5
    |
201 | def _collect_reference_edits(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^
202 |     code: str,
203 |     *,
    |

PLR0912 Too many branches (13 > 12)
   --> src/code_scalpel/surgery/surgical_extractor.py:643:9
    |
641 |         return cls(code, file_path=resolved_path)
642 |
643 |     def _ensure_parsed(self) -> None:
    |         ^^^^^^^^^^^^^^
644 |         """Parse the code if not already done."""
645 |         if self._parsed:
    |

PLR0912 Too many branches (14 > 12)
    --> src/code_scalpel/surgery/surgical_extractor.py:1248:9
     |
1246 |         )
1247 |
1248 |     def get_method_with_context(
     |         ^^^^^^^^^^^^^^^^^^^^^^^
1249 |         self, class_name: str, method_name: str, max_depth: int = 2
1250 |     ) -> ContextualExtraction:
     |

PLR0912 Too many branches (16 > 12)
    --> src/code_scalpel/surgery/surgical_extractor.py:1495:13
     |
1493 |             return extractor_cache[path]
1494 |
1495 |         def resolve_symbol(
     |             ^^^^^^^^^^^^^^
1496 |             symbol_name: str,
1497 |             module_info: tuple[str | None, str, str],
     |

PLR0912 Too many branches (17 > 12)
    --> src/code_scalpel/surgery/surgical_extractor.py:2035:5
     |
2035 | def promote_variables(code: str, function_name: str) -> VariablePromotionResult:
     |     ^^^^^^^^^^^^^^^^^
2036 |     """
2037 |     Analyze a function and promote local variables to parameters.
     |

PLR0912 Too many branches (21 > 12)
    --> src/code_scalpel/surgery/surgical_extractor.py:2242:5
     |
2242 | def extract_as_microservice(
     |     ^^^^^^^^^^^^^^^^^^^^^^^
2243 |     code: str, function_name: str, host: str = "0.0.0.0", port: int = 8000
2244 | ) -> MicroserviceExtractionResult:
     |

PLR0912 Too many branches (35 > 12)
    --> src/code_scalpel/surgery/surgical_extractor.py:2673:5
     |
2673 | def detect_closure_variables(code: str, function_name: str) -> ClosureAnalysisResult:
     |     ^^^^^^^^^^^^^^^^^^^^^^^^
2674 |     """
2675 |     Detect variables captured from outer scopes (closures).
     |

PLR0912 Too many branches (25 > 12)
    --> src/code_scalpel/surgery/surgical_extractor.py:2905:5
     |
2905 | def suggest_dependency_injection(
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
2906 |     code: str, function_name: str
2907 | ) -> DependencyInjectionResult:
     |

PLR0912 Too many branches (18 > 12)
    --> src/code_scalpel/surgery/surgical_extractor.py:3137:5
     |
3137 | def resolve_organization_wide(
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^
3138 |     code: str,
3139 |     function_name: str,
     |

PLR0912 Too many branches (31 > 12)
    --> src/code_scalpel/surgery/surgical_extractor.py:3331:5
     |
3331 | def extract_with_custom_pattern(
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
3332 |     pattern: str,
3333 |     pattern_type: str = "regex",
     |

PLR0912 Too many branches (21 > 12)
    --> src/code_scalpel/surgery/surgical_extractor.py:3556:5
     |
3556 | def detect_service_boundaries(
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^
3557 |     project_root: str | None = None,
3558 |     min_isolation_score: float = 0.6,
     |

PLR0912 Too many branches (16 > 12)
   --> src/code_scalpel/surgery/surgical_patcher.py:216:5
    |
216 | def _collect_same_file_references(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
217 |     code: str,
218 |     target_type: str,
    |

PLR0912 Too many branches (13 > 12)
    --> src/code_scalpel/surgery/surgical_patcher.py:1047:9
     |
1045 |         )
1046 |
1047 |     def rename_symbol(
     |         ^^^^^^^^^^^^^
1048 |         self, target_type: str, target_name: str, new_name: str
1049 |     ) -> PatchResult:
     |

PLR0912 Too many branches (21 > 12)
    --> src/code_scalpel/surgery/surgical_patcher.py:1359:9
     |
1357 |         self.length = len(code)
1358 |
1359 |     def find_matching_brace(self, start_pos: int) -> int:
     |         ^^^^^^^^^^^^^^^^^^^
1360 |         """
1361 |         Find the position of the closing brace matching the opening brace at start_pos.
     |

PLR0912 Too many branches (13 > 12)
    --> src/code_scalpel/surgery/surgical_patcher.py:1677:9
     |
1675 |         return methods
1676 |
1677 |     def _find_standalone_functions(self) -> list[PolyglotSymbolLocation]:
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^
1678 |         """Find standalone function declarations."""
1679 |         functions: list[PolyglotSymbolLocation] = []
     |

PLR0912 Too many branches (13 > 12)
    --> src/code_scalpel/surgery/surgical_patcher.py:2483:9
     |
2481 |         return backup_path
2482 |
2483 |     def rename_symbol(
     |         ^^^^^^^^^^^^^
2484 |         self, target_type: str, target_name: str, new_name: str
2485 |     ) -> PatchResult:
     |

PLR0912 Too many branches (16 > 12)
   --> src/code_scalpel/surgery/unified_extractor.py:507:5
    |
507 | def detect_language(
    |     ^^^^^^^^^^^^^^^
508 |     file_path: Optional[str] = None, code: Optional[str] = None
509 | ) -> Language:
    |

PLR0912 Too many branches (19 > 12)
   --> src/code_scalpel/symbolic_execution_tools/engine.py:384:9
    |
382 |         return result
383 |
384 |     def _analyze_uncached(self, code: str, language: str) -> AnalysisResult:
    |         ^^^^^^^^^^^^^^^^^
385 |         """Perform symbolic analysis without caching (internal method)."""
386 |         # Fresh components for this analysis
    |

PLR0912 Too many branches (13 > 12)
    --> src/code_scalpel/symbolic_execution_tools/ir_interpreter.py:1237:9
     |
1235 |             return None
1236 |
1237 |     def _eval_compare(self, expr: IRCompare, state: SymbolicState) -> Optional[BoolRef]:
     |         ^^^^^^^^^^^^^
1238 |         """Evaluate a comparison."""
1239 |         left = self._eval_expr(expr.left, state)
     |

PLR0912 Too many branches (23 > 12)
   --> src/code_scalpel/symbolic_execution_tools/type_inference.py:305:9
    |
303 |         return self._combine_types_for_binop(left_type, node.op, right_type)
304 |
305 |     def _combine_types_for_binop(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^
306 |         self, left: InferredType, op: ast.operator, right: InferredType
307 |     ) -> InferredType:
    |

PLR0912 Too many branches (13 > 12)
  --> src/code_scalpel/utilities/path_resolution.py:30:5
   |
30 | def resolve_file_path(
   |     ^^^^^^^^^^^^^^^^^
31 |     file_path: str,
32 |     workspace_root: Optional[str] = None,
   |

Found 154 errors.
