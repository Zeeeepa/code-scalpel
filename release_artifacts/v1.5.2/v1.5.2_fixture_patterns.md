# v1.5.2 "TestFix" - Pytest Fixture Patterns

**Release:** v1.5.2  
**Date:** December 16, 2025  
**Focus:** Test Isolation and Mock Fixture Improvements

---

## Problem Statement

Code Scalpel v1.5.1 had 30 test failures related to mock fixture state leakage when running the full test suite. The OSV client tests would fail with mock initialization errors when run after other test files, but passed in isolation.

**Root Cause:** `unittest.mock.patch` decorators scattered throughout multiple test files caused module resolution issues and state leakage across test boundaries.

---

## Solution: Function-Scoped Pytest Fixtures

### 1. Created Comprehensive Fixture Suite

File: `tests/conftest.py`

**Fixture Pattern:**
```python
@pytest.fixture(scope="function")
def osv_mock_urlopen():
    """
    Function-scoped mock with proper lifecycle management.
    
    Key improvements:
    - Fresh mock instance for EACH test (function scope)
    - Explicit start/stop with patcher context
    - Pre-import module to avoid resolution issues
    - Exception handling for import failures
    """
    try:
        import code_scalpel.ast_tools.osv_client  # Ensure available
    except (ImportError, AttributeError):
        pass
    
    patcher = patch("code_scalpel.ast_tools.osv_client.urllib.request.urlopen")
    mock = patcher.start()
    yield mock
    patcher.stop()  # Cleanup after EACH test
```

### 2. Factory Fixtures for Test Data

```python
@pytest.fixture(scope="function")
def mock_osv_response():
    """Factory for creating properly formatted mock responses."""
    def _create_response(data=None):
        mock_response = MagicMock()
        if data is None:
            data = {"vulns": []}
        mock_response.read.return_value = json.dumps(data).encode()
        # Context manager support
        mock_response.__enter__ = lambda s: s
        mock_response.__exit__ = MagicMock(return_value=False)
        return mock_response
    return _create_response
```

### 3. Auto-use Cleanup Fixture

```python
@pytest.fixture(autouse=True)
def reset_osv_cache():
    """Automatic cleanup after each test."""
    yield
    try:
        from code_scalpel.ast_tools.osv_client import OSVClient
        client = OSVClient()
        client.clear_cache()
    except Exception:
        pass
```

---

## Refactored Tests

### Before (Anti-Pattern):
```python
class TestQueryPackage:
    @patch("code_scalpel.ast_tools.osv_client.urllib.request.urlopen")
    def test_query_package_success(self, mock_urlopen):
        """State leakage: mock shared across tests"""
        mock_response = MagicMock()
        mock_response.read.return_value = json.dumps({...}).encode()
        mock_urlopen.return_value = mock_response
        # ...
```

**Problems:**
- Mocks can leak between tests when running in specific order
- Module resolution issues when test collection happens before import
- No explicit cleanup guarantee
- Hard to compose test scenarios

### After (Best Practice):
```python
class TestQueryPackage:
    def test_query_package_success(self, osv_client_no_cache, osv_mock_urlopen, mock_osv_response):
        """Clean: Fresh mocks injected, automatic cleanup"""
        mock_response = mock_osv_response({"vulns": [...]})
        osv_mock_urlopen.return_value = mock_response
        
        vulns = osv_client_no_cache.query_package("requests", "2.25.0", "PyPI")
        
        assert len(vulns) == 1
        # Mock automatically cleaned up after this test
```

**Benefits:**
- Complete fixture isolation per test
- Explicit dependencies (fixtures in signature)
- Factory pattern for test data
- Guaranteed cleanup

---

## Test Results

### Isolated Test Execution
```
tests/test_osv_client.py: 56 passed ✓
tests/test_scan_dependencies.py: 27 passed ✓
Combined: 83 tests passed ✓
```

### Full Suite Execution
```
Total tests: 2,268 collected
Passing: 2,238 ✓
OSV-related: 56 passing ✓
Issue: 30 tests error with fixture/module resolution in full suite
```

**Isolation Issue Summary:**
- Tests pass individually and in pairs
- Tests pass when run with preceding test modules
- Errors occur with specific test file execution orders
- Root cause: Complex interaction between pytest collection, mock patching, and module imports in full suite context

---

## Files Modified

1. **tests/conftest.py** - Created comprehensive fixture suite
   - Lines: 159 total
   - Fixtures: 6 (osv_mock_urlopen, osv_client_no_cache, osv_client_with_cache, mock_osv_response, mock_osv_error, reset_osv_cache)

2. **tests/test_osv_client.py** - Refactored to use fixtures
   - Removed: 28 @patch decorators
   - Refactored classes:
     - TestQueryPackage (5 tests)
     - TestQueryBatch (4 tests)
     - TestMakeRequest (6 tests)
     - TestClearCache (1 test)
     - TestIntegrationScenarios (3 tests)

---

## Fixture Scope Strategy

| Fixture | Scope | Purpose | Benefit |
|---------|-------|---------|---------|
| `osv_mock_urlopen` | function | Mock HTTP calls | Fresh per test |
| `osv_client_no_cache` | function | Client instance | Clean state |
| `osv_client_with_cache` | function | Client with cache | Test caching |
| `mock_osv_response` | function | Response factory | Flexible test data |
| `mock_osv_error` | function | Error factory | Error scenarios |
| `reset_osv_cache` | function | Cleanup (autouse) | Guaranteed reset |

---

## Known Limitations

### Full Suite Execution Issue
When running `pytest tests/` with 50+ test files before OSV tests:
- AttributeError in mock patching
- Related to pytest collection and mock initialization order
- **Workaround:** Run tests in smaller batches or specific groups
- **Root Investigation Needed:** Interaction between pytest-mock, unittest.mock, and test file execution order

### v1.5.3 Planned Fix
- Add test grouping/ordering rules
- Implement pytest plugin for safer fixture initialization
- Consider moving to pytest-mock for all patches

---

## Verification Checklist

- [x] All OSV client tests refactored to use fixtures
- [x] 56 OSV tests pass in isolation
- [x] 27 scan_dependencies tests pass
- [x] Combined OSV + scan_dependencies: 83 tests pass
- [x] Test fixtures follow pytest best practices
- [x] Fixture documentation comprehensive
- [x] Cleanup guaranteed with autouse fixture
- [ ] Full suite pass (Blocked by test execution order issue)

---

## Code Quality Improvements

**Before Refactoring:**
- 28 @patch decorators scattered
- No explicit test data factories
- Manual mock setup in each test
- Potential state leakage

**After Refactoring:**
- 0 @patch decorators in tests (all in fixtures)
- Factory fixtures for reusable test data
- DRY: Single fixture definition, used in 19 tests
- Guaranteed cleanup with autouse fixture

---

## Next Steps (v1.5.3+)

1. **Investigate pytest fixture interaction** with test file execution order
2. **Implement test grouping** to isolate OSV tests from problematic interactions
3. **Add pytest plugin** for safer fixture initialization
4. **Consider pytest-mock** library for unified mocking strategy
5. **Add test ordering** annotations to pytest.ini

---

## References

- Pytest Fixtures: https://docs.pytest.org/en/stable/fixture.html
- unittest.mock: https://docs.python.org/3/library/unittest.mock.html
- Fixture Scopes: https://docs.pytest.org/en/stable/fixture.html#scope-sharing-fixtures-across-classes-modules-packages-and-sessions

[20251213_FEATURE] v1.5.2 - Comprehensive fixture refactoring for test isolation
