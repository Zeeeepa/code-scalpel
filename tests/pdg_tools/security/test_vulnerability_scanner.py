"""
Tests for vulnerability_scanner.py - A06:2021 Vulnerable Components detection.

[20251219_FEATURE] v3.0.4 - A06 Vulnerable Components
"""

import json
from pathlib import Path
from unittest.mock import MagicMock, patch

import pytest

from code_scalpel.security.dependencies.vulnerability_scanner import (
    DependencyParser,
    OSVClient,
    VulnerabilityFinding,
    VulnerabilityScanner,
    scan_dependencies,
)

# =============================================================================
# DependencyParser Tests
# =============================================================================


class TestDependencyParserPackageJson:
    """Tests for package.json parsing."""

    def test_parse_basic_dependencies(self, tmp_path: Path):
        """Test parsing basic package.json with dependencies."""
        package_json = tmp_path / "package.json"
        package_json.write_text(
            json.dumps(
                {
                    "dependencies": {"express": "^4.18.2", "lodash": "~4.17.21"},
                    "devDependencies": {"jest": "29.7.0"},
                }
            )
        )

        deps = DependencyParser.parse_package_json(package_json)

        assert len(deps) == 3
        assert any(d.name == "express" and d.version == "4.18.2" for d in deps)
        assert any(d.name == "lodash" and d.version == "4.17.21" for d in deps)
        assert any(d.name == "jest" and d.is_dev for d in deps)

    def test_parse_workspace_protocol_skipped(self, tmp_path: Path):
        """Test that workspace: protocol dependencies are skipped."""
        package_json = tmp_path / "package.json"
        package_json.write_text(
            json.dumps(
                {"dependencies": {"workspace-pkg": "workspace:*", "real-pkg": "1.0.0"}}
            )
        )

        deps = DependencyParser.parse_package_json(package_json)

        assert len(deps) == 1
        assert deps[0].name == "real-pkg"

    def test_parse_version_ranges(self, tmp_path: Path):
        """Test parsing various version range formats."""
        package_json = tmp_path / "package.json"
        package_json.write_text(
            json.dumps(
                {
                    "dependencies": {
                        "pkg1": ">=1.0.0",
                        "pkg2": "1.0.0 - 2.0.0",
                        "pkg3": "1.0.0 || 2.0.0",
                    }
                }
            )
        )

        deps = DependencyParser.parse_package_json(package_json)

        assert len(deps) == 3
        assert any(d.name == "pkg1" and d.version == "1.0.0" for d in deps)
        assert any(d.name == "pkg2" and d.version == "1.0.0" for d in deps)
        assert any(d.name == "pkg3" and d.version == "1.0.0" for d in deps)

    def test_parse_empty_dependencies(self, tmp_path: Path):
        """Test parsing package.json with no dependencies."""
        package_json = tmp_path / "package.json"
        package_json.write_text(json.dumps({"name": "test"}))

        deps = DependencyParser.parse_package_json(package_json)
        assert len(deps) == 0


class TestDependencyParserPomXml:
    """Tests for pom.xml parsing."""

    def test_parse_basic_pom(self, tmp_path: Path):
        """Test parsing basic pom.xml."""
        pom_xml = tmp_path / "pom.xml"
        pom_xml.write_text(
            """<?xml version="1.0"?>
<project>
    <dependencies>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-core</artifactId>
            <version>5.3.20</version>
        </dependency>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.13.2</version>
            <scope>test</scope>
        </dependency>
    </dependencies>
</project>
"""
        )

        deps = DependencyParser.parse_pom_xml(pom_xml)

        assert len(deps) == 2
        assert any(
            d.name == "org.springframework:spring-core" and d.version == "5.3.20"
            for d in deps
        )
        assert any(d.name == "junit:junit" and d.is_dev for d in deps)

    def test_parse_pom_with_namespace(self, tmp_path: Path):
        """Test parsing pom.xml with Maven namespace."""
        pom_xml = tmp_path / "pom.xml"
        pom_xml.write_text(
            """<?xml version="1.0"?>
<project xmlns="http://maven.apache.org/POM/4.0.0">
    <dependencies>
        <dependency>
            <groupId>com.google.guava</groupId>
            <artifactId>guava</artifactId>
            <version>31.1-jre</version>
        </dependency>
    </dependencies>
</project>
"""
        )

        deps = DependencyParser.parse_pom_xml(pom_xml)

        assert len(deps) == 1
        assert deps[0].name == "com.google.guava:guava"
        assert deps[0].version == "31.1-jre"

    def test_skip_property_versions(self, tmp_path: Path):
        """Test that property reference versions are skipped."""
        pom_xml = tmp_path / "pom.xml"
        pom_xml.write_text(
            """<?xml version="1.0"?>
<project>
    <dependencies>
        <dependency>
            <groupId>org.test</groupId>
            <artifactId>test</artifactId>
            <version>${project.version}</version>
        </dependency>
    </dependencies>
</project>
"""
        )

        deps = DependencyParser.parse_pom_xml(pom_xml)
        assert len(deps) == 0


class TestDependencyParserBuildGradle:
    """Tests for build.gradle parsing."""

    def test_parse_string_notation(self, tmp_path: Path):
        """Test parsing Gradle string notation dependencies."""
        build_gradle = tmp_path / "build.gradle"
        build_gradle.write_text(
            """
plugins {
    id 'java'
}

dependencies {
    implementation 'org.springframework:spring-core:5.3.20'
    testImplementation 'junit:junit:4.13.2'
    api "com.google.guava:guava:31.1-jre"
}
"""
        )

        deps = DependencyParser.parse_build_gradle(build_gradle)

        assert len(deps) == 3
        assert any(d.name == "org.springframework:spring-core" for d in deps)
        assert any(d.is_dev and d.name == "junit:junit" for d in deps)


class TestDependencyParserRequirementsTxt:
    """Tests for requirements.txt parsing."""

    def test_parse_basic_requirements(self, tmp_path: Path):
        """Test parsing basic requirements.txt."""
        requirements = tmp_path / "requirements.txt"
        requirements.write_text(
            """
# This is a comment
requests==2.28.0
flask>=2.0.0
django~=4.0
numpy<2.0
"""
        )

        deps = DependencyParser.parse_requirements_txt(requirements)

        assert len(deps) == 4
        assert any(d.name == "requests" and d.version == "2.28.0" for d in deps)
        assert any(d.name == "flask" and d.version == "2.0.0" for d in deps)

    def test_skip_comments_and_flags(self, tmp_path: Path):
        """Test that comments and pip flags are skipped."""
        requirements = tmp_path / "requirements.txt"
        requirements.write_text(
            """
# Comment
-r other-requirements.txt
--index-url https://pypi.org/simple
requests==2.28.0
"""
        )

        deps = DependencyParser.parse_requirements_txt(requirements)

        assert len(deps) == 1
        assert deps[0].name == "requests"


# =============================================================================
# OSVClient Tests (Mocked)
# =============================================================================


class TestOSVClient:
    """Tests for OSV API client."""

    @patch("httpx.Client")
    def test_query_single_with_vulns(self, mock_client_class):
        """Test querying a single package that has vulnerabilities."""
        mock_response = MagicMock()
        mock_response.json.return_value = {
            "vulns": [
                {
                    "id": "GHSA-test-1234",
                    "summary": "Test vulnerability",
                    "aliases": ["CVE-2024-1234"],
                }
            ]
        }
        mock_response.raise_for_status = MagicMock()

        mock_client = MagicMock()
        mock_client.post.return_value = mock_response
        mock_client_class.return_value = mock_client

        client = OSVClient()
        result = client.query_single("test-pkg", "1.0.0", "npm")

        assert len(result) == 1
        assert result[0]["id"] == "GHSA-test-1234"

    @patch("httpx.Client")
    def test_query_single_no_vulns(self, mock_client_class):
        """Test querying a package with no vulnerabilities."""
        mock_response = MagicMock()
        mock_response.json.return_value = {}
        mock_response.raise_for_status = MagicMock()

        mock_client = MagicMock()
        mock_client.post.return_value = mock_response
        mock_client_class.return_value = mock_client

        client = OSVClient()
        result = client.query_single("safe-pkg", "1.0.0", "npm")

        assert result == []


# =============================================================================
# VulnerabilityScanner Tests (Integration-style with mocking)
# =============================================================================


class TestVulnerabilityScanner:
    """Tests for VulnerabilityScanner."""

    def test_scan_nonexistent_file(self):
        """Test scanning a file that doesn't exist."""
        scanner = VulnerabilityScanner()
        result = scanner.scan_file("/nonexistent/package.json")

        assert result.dependencies_scanned == 0
        assert len(result.errors) == 1
        assert "not found" in result.errors[0].lower()

    def test_scan_empty_directory(self, tmp_path: Path):
        """Test scanning an empty directory."""
        scanner = VulnerabilityScanner()
        result = scanner.scan_directory(tmp_path)

        assert result.dependencies_scanned == 0
        assert result.vulnerabilities_found == 0

    @patch.object(OSVClient, "query_batch")
    def test_scan_file_with_vulns(self, mock_query_batch, tmp_path: Path):
        """Test scanning a file that has vulnerable dependencies."""
        # Create a package.json
        package_json = tmp_path / "package.json"
        package_json.write_text(
            json.dumps({"dependencies": {"lodash": "4.17.20"}})
        )  # Known vulnerable version

        # Mock OSV response
        mock_query_batch.return_value = {
            "lodash@4.17.20": [
                {
                    "id": "GHSA-p6mc-m468-83gw",
                    "aliases": ["CVE-2021-23337"],
                    "summary": "Prototype Pollution in lodash",
                    "severity": [{"type": "CVSS_V3", "score": 7.2}],
                    "affected": [{"ranges": [{"events": [{"fixed": "4.17.21"}]}]}],
                    "references": [],
                }
            ]
        }

        scanner = VulnerabilityScanner()
        result = scanner.scan_file(package_json)

        assert result.dependencies_scanned == 1
        assert result.vulnerabilities_found == 1
        assert result.findings[0].id == "GHSA-p6mc-m468-83gw"
        assert result.findings[0].cve_id == "CVE-2021-23337"
        assert "4.17.21" in result.findings[0].fixed_versions

    @patch.object(OSVClient, "query_batch")
    def test_scan_directory_recursive(self, mock_query_batch, tmp_path: Path):
        """Test scanning a directory recursively."""
        # Create package.json in root
        (tmp_path / "package.json").write_text(
            json.dumps({"dependencies": {"express": "4.17.0"}})
        )

        # Create pom.xml in subdirectory
        subdir = tmp_path / "backend"
        subdir.mkdir()
        (subdir / "pom.xml").write_text(
            """<?xml version="1.0"?>
<project>
    <dependencies>
        <dependency>
            <groupId>org.apache.logging.log4j</groupId>
            <artifactId>log4j-core</artifactId>
            <version>2.14.0</version>
        </dependency>
    </dependencies>
</project>
"""
        )

        mock_query_batch.return_value = {}  # No vulns for simplicity

        scanner = VulnerabilityScanner()
        result = scanner.scan_directory(tmp_path)

        assert result.dependencies_scanned == 2  # express + log4j-core


class TestVulnerabilityFinding:
    """Tests for VulnerabilityFinding model."""

    def test_cve_id_extraction(self):
        """Test extracting CVE ID from aliases."""
        finding = VulnerabilityFinding(
            id="GHSA-test-1234",
            aliases=["CVE-2024-1234", "SNYK-JS-TEST-1234"],
            package_name="test",
            package_version="1.0.0",
            ecosystem="npm",
        )

        assert finding.cve_id == "CVE-2024-1234"

    def test_no_cve_id(self):
        """Test when no CVE ID is in aliases."""
        finding = VulnerabilityFinding(
            id="GHSA-test-1234",
            aliases=["SNYK-JS-TEST-1234"],
            package_name="test",
            package_version="1.0.0",
            ecosystem="npm",
        )

        assert finding.cve_id is None


# =============================================================================
# Convenience Function Tests
# =============================================================================


class TestScanDependenciesFunction:
    """Tests for the scan_dependencies convenience function."""

    @patch.object(OSVClient, "query_batch")
    def test_scan_dependencies_file(self, mock_query_batch, tmp_path: Path):
        """Test scan_dependencies with a file path."""
        package_json = tmp_path / "package.json"
        package_json.write_text(json.dumps({"dependencies": {"lodash": "4.17.21"}}))

        mock_query_batch.return_value = {}

        result = scan_dependencies(package_json)

        assert result.dependencies_scanned == 1
        assert result.vulnerabilities_found == 0

    @patch.object(OSVClient, "query_batch")
    def test_scan_dependencies_directory(self, mock_query_batch, tmp_path: Path):
        """Test scan_dependencies with a directory path."""
        (tmp_path / "requirements.txt").write_text("requests==2.28.0\n")

        mock_query_batch.return_value = {}

        result = scan_dependencies(tmp_path)

        assert result.dependencies_scanned == 1


# =============================================================================
# Edge Cases and Error Handling
# =============================================================================


class TestEdgeCases:
    """Tests for edge cases and error handling."""

    def test_malformed_package_json(self, tmp_path: Path):
        """Test handling of malformed package.json."""
        package_json = tmp_path / "package.json"
        package_json.write_text("{ invalid json }")

        with pytest.raises(ValueError):
            DependencyParser.parse_package_json(package_json)

    def test_malformed_pom_xml(self, tmp_path: Path):
        """Test handling of malformed pom.xml."""
        pom_xml = tmp_path / "pom.xml"
        pom_xml.write_text("<project><invalid")

        with pytest.raises(ValueError):
            DependencyParser.parse_pom_xml(pom_xml)

    def test_scanner_context_manager(self):
        """Test VulnerabilityScanner as context manager."""
        with VulnerabilityScanner() as scanner:
            assert scanner is not None
        # No exception means success
