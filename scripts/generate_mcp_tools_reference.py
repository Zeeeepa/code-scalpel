"""Generate a reference doc of currently registered MCP tools.

This script starts from the actual tool registry exposed by the MCP server,
not a hand-maintained list, so it reflects what the package ships today.

Output:
  - docs/reference/mcp_tools_current.md

Notes:
  - This is a documentation generator; it does not execute untrusted code.
  - It runs the MCP server over stdio and queries tools via list_tools().
"""

from __future__ import annotations

import asyncio
import json
import os
import sys
from dataclasses import dataclass
from datetime import timedelta
from pathlib import Path
from typing import Any

from mcp import ClientSession, StdioServerParameters
from mcp.client.stdio import stdio_client


@dataclass(frozen=True)
class ToolDoc:
    name: str
    description: str | None
    input_schema: dict[str, Any] | None


def _repo_root() -> Path:
    return Path(__file__).resolve().parents[1]


def _pythonpath_env(repo_root: Path) -> dict[str, str]:
    env = os.environ.copy()
    existing = env.get("PYTHONPATH", "")
    parts = [str(repo_root)]
    if existing:
        parts.append(existing)
    env["PYTHONPATH"] = os.pathsep.join(parts)
    return env


def _as_dict(obj: Any) -> Any:
    if obj is None:
        return None
    if isinstance(obj, dict):
        return obj
    if hasattr(obj, "model_dump"):
        return obj.model_dump()
    if hasattr(obj, "dict"):
        return obj.dict()
    # Fallback: best-effort JSON
    return json.loads(json.dumps(obj, default=str))


def _format_json_block(data: Any) -> str:
    rendered = json.dumps(data, indent=2, sort_keys=True, ensure_ascii=False)
    return f"```json\n{rendered}\n```"


async def _fetch_tools(project_root: Path) -> list[ToolDoc]:
    repo_root = _repo_root()

    # Always document the full tool surface shipped by this repo.
    env = _pythonpath_env(repo_root)
    env["CODE_SCALPEL_TIER"] = "enterprise"

    params = StdioServerParameters(
        command=sys.executable,
        args=["-m", "code_scalpel.mcp.server", "--root", str(project_root)],
        env=env,
    )

    async with stdio_client(params) as (read, write):
        async with ClientSession(read, write) as session:
            await session.initialize()
            tools_result = await session.list_tools()

    tools: list[ToolDoc] = []
    for tool in tools_result.tools:
        # mcp Tool objects commonly expose .name, .description, .inputSchema
        name = getattr(tool, "name", None)
        if not name:
            continue
        description = getattr(tool, "description", None)
        input_schema = getattr(tool, "inputSchema", None)
        tools.append(
            ToolDoc(
                name=str(name),
                description=str(description) if description is not None else None,
                input_schema=_as_dict(input_schema) if input_schema is not None else None,
            )
        )

    tools.sort(key=lambda t: t.name)
    return tools


def _write_markdown(out_path: Path, tools: list[ToolDoc]) -> None:
    out_path.parent.mkdir(parents=True, exist_ok=True)

    lines: list[str] = []
    lines.append("# MCP Tools (Current)")
    lines.append("")
    lines.append("This document is generated from the current MCP tool registry shipped by this repo.")
    lines.append("")
    lines.append(f"- Generated by: `scripts/generate_mcp_tools_reference.py`")
    lines.append(f"- Tool count: **{len(tools)}**")
    lines.append("")

    lines.append("## Index")
    lines.append("")
    for tool in tools:
        anchor = tool.name.lower().replace("_", "-")
        lines.append(f"- [{tool.name}](#{anchor})")
    lines.append("")

    for tool in tools:
        lines.append(f"## {tool.name}")
        lines.append("")
        if tool.description:
            lines.append(tool.description.strip())
            lines.append("")
        if tool.input_schema is not None:
            lines.append("### Input schema")
            lines.append("")
            lines.append(_format_json_block(tool.input_schema))
            lines.append("")
        else:
            lines.append("### Input schema")
            lines.append("")
            lines.append("(No schema provided by MCP server)")
            lines.append("")

    out_path.write_text("\n".join(lines).rstrip() + "\n", encoding="utf-8")


async def main() -> int:
    # Use a tiny, empty project root so tools that require a root can still initialize.
    project_root = Path(os.environ.get("CODE_SCALPEL_DOC_PROJECT_ROOT", ""))
    if not project_root:
        project_root = _repo_root() / "evidence" / "mcp_tools_docgen"
        project_root.mkdir(parents=True, exist_ok=True)
        (project_root / "README.txt").write_text(
            "Temporary project root for MCP tool documentation generation.\n",
            encoding="utf-8",
        )

    tools = await asyncio.wait_for(_fetch_tools(project_root), timeout=timedelta(seconds=90).total_seconds())

    out_path = _repo_root() / "docs" / "reference" / "mcp_tools_current.md"
    _write_markdown(out_path, tools)

    print(f"Wrote {out_path} ({len(tools)} tools)")
    return 0


if __name__ == "__main__":
    raise SystemExit(asyncio.run(main()))
