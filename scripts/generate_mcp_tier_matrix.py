"""Generate a tier matrix doc of MCP tools.

This script queries the *live MCP tool registry* via MCP stdio for each tier and
writes a Markdown matrix.

Output:
  - docs/reference/mcp_tools_by_tier.md

Notes:
  - This is a documentation generator; it does not execute untrusted code.
  - It starts the MCP server over stdio and queries tools via list_tools().
"""

from __future__ import annotations

import asyncio
import os
import sys
from dataclasses import dataclass
from datetime import timedelta
from pathlib import Path

from mcp import ClientSession, StdioServerParameters
from mcp.client.stdio import stdio_client

TIERS: tuple[str, ...] = ("community", "pro", "enterprise")


@dataclass(frozen=True)
class TierTools:
    tier: str
    tools: set[str]


def _repo_root() -> Path:
    return Path(__file__).resolve().parents[1]


def _pythonpath_env(repo_root: Path) -> dict[str, str]:
    env = os.environ.copy()
    existing = env.get("PYTHONPATH", "")
    parts = [str(repo_root)]
    if existing:
        parts.append(existing)
    env["PYTHONPATH"] = os.pathsep.join(parts)
    return env


async def _fetch_tools_for_tier(project_root: Path, tier: str) -> TierTools:
    repo_root = _repo_root()

    env = _pythonpath_env(repo_root)
    env["CODE_SCALPEL_TIER"] = tier

    params = StdioServerParameters(
        command=sys.executable,
        args=["-m", "code_scalpel.mcp.server", "--root", str(project_root)],
        env=env,
    )

    async with stdio_client(params) as (read, write):
        async with ClientSession(read, write) as session:
            await session.initialize()
            tools_result = await session.list_tools()

    tool_names = {t.name for t in tools_result.tools}
    return TierTools(tier=tier, tools=set(tool_names))


def _write_matrix(out_path: Path, by_tier: dict[str, TierTools]) -> None:
    out_path.parent.mkdir(parents=True, exist_ok=True)

    # Collect union of all tools we observed.
    all_tools: set[str] = set()
    for tt in by_tier.values():
        all_tools |= tt.tools

    def mark(tool: str, tier: str) -> str:
        return "✅" if tool in by_tier[tier].tools else "❌"

    lines: list[str] = []
    lines.append("# MCP Tools by Tier (Current)")
    lines.append("")
    lines.append(
        "This document is generated from the MCP server tool registry for each tier."
    )
    lines.append("")
    lines.append("- Generated by: `scripts/generate_mcp_tier_matrix.py`")
    lines.append("")

    # Summary counts
    for tier in TIERS:
        lines.append(f"- {tier}: **{len(by_tier[tier].tools)}** tools")
    lines.append("")

    # Matrix
    lines.append("| MCP Tool ID | Community | Pro | Enterprise |")
    lines.append("|---|---:|---:|---:|")
    for tool in sorted(all_tools):
        lines.append(
            f"| `{tool}` | {mark(tool, 'community')} | {mark(tool, 'pro')} | {mark(tool, 'enterprise')} |"
        )
    lines.append("")

    lines.append("Legend:")
    lines.append("- ✅ Included in tier")
    lines.append("- ❌ Not included in tier")
    lines.append("")

    out_path.write_text("\n".join(lines).rstrip() + "\n", encoding="utf-8")


async def main() -> int:
    # Use a tiny, empty project root so tools that require a root can still initialize.
    project_root = Path(os.environ.get("CODE_SCALPEL_DOC_PROJECT_ROOT", ""))
    if not project_root:
        project_root = _repo_root() / "evidence" / "mcp_tools_docgen"
        project_root.mkdir(parents=True, exist_ok=True)
        (project_root / "README.txt").write_text(
            "Temporary project root for MCP tier matrix documentation generation.\n",
            encoding="utf-8",
        )

    by_tier: dict[str, TierTools] = {}
    for tier in TIERS:
        by_tier[tier] = await asyncio.wait_for(
            _fetch_tools_for_tier(project_root, tier),
            timeout=timedelta(seconds=90).total_seconds(),
        )

    out_path = _repo_root() / "docs" / "reference" / "mcp_tools_by_tier.md"
    _write_matrix(out_path, by_tier)

    print(f"Wrote {out_path}")
    return 0


if __name__ == "__main__":
    raise SystemExit(asyncio.run(main()))
