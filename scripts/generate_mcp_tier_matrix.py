"""Generate a tier matrix doc of MCP tools.

This script queries the *live MCP tool registry* via MCP stdio for each tier and
writes a Markdown matrix.

Output:
  - docs/reference/mcp_tools_by_tier.md

Notes:
  - This is a documentation generator; it does not execute untrusted code.
  - It starts the MCP server over stdio and queries tools via list_tools().
"""

from __future__ import annotations

import asyncio
import os
import sys
from dataclasses import dataclass
from datetime import timedelta
from pathlib import Path

from mcp import ClientSession, StdioServerParameters
from mcp.client.stdio import stdio_client

TIERS: tuple[str, ...] = ("community", "pro", "enterprise")


@dataclass(frozen=True)
class TierTools:
    tier: str
    tools: set[str]


def _repo_root() -> Path:
    return Path(__file__).resolve().parents[1]


def _pythonpath_env(repo_root: Path) -> dict[str, str]:
    env = os.environ.copy()
    existing = env.get("PYTHONPATH", "")
    parts = [str(repo_root)]
    if existing:
        parts.append(existing)
    env["PYTHONPATH"] = os.pathsep.join(parts)
    return env


def _setup_licenses_env(env: dict[str, str]) -> dict[str, str]:
    """Configure license environment for tier matrix documentation generation.

    Real licenses from CI secrets ensure docs reflect actual entitlement logic.
    No fallback values - fail loudly if licenses are not configured.
    """
    pro_jwt = os.environ.get("TEST_PRO_LICENSE_JWT")
    enterprise_jwt = os.environ.get("TEST_ENTERPRISE_LICENSE_JWT")

    missing = []
    if not pro_jwt:
        missing.append("TEST_PRO_LICENSE_JWT")
    if not enterprise_jwt:
        missing.append("TEST_ENTERPRISE_LICENSE_JWT")

    if missing:
        raise RuntimeError(
            f"Licenses required for docs generation: {', '.join(missing)}\n"
            "Set TEST_PRO_LICENSE_JWT and TEST_ENTERPRISE_LICENSE_JWT environment variables.\n"
            "This ensures docs reflect real entitlement logic, not fallback defaults."
        )

    # Write licenses to temp location
    license_path = Path(os.environ.get("CODE_SCALPEL_DOC_PROJECT_ROOT", "/tmp")) / ".code-scalpel"
    license_path.mkdir(parents=True, exist_ok=True)

    # Type assertions: after above checks, these are guaranteed to be non-None
    assert pro_jwt is not None
    assert enterprise_jwt is not None

    # Store the licenses for later use
    env["_TMP_PRO_LICENSE_JWT"] = pro_jwt
    env["_TMP_ENTERPRISE_LICENSE_JWT"] = enterprise_jwt

    return env


async def _fetch_tools_for_tier(project_root: Path, tier: str, licenses: dict[str, str]) -> TierTools:
    repo_root = _repo_root()

    env = _pythonpath_env(repo_root)
    env["CODE_SCALPEL_TIER"] = tier

    # Set up license for this tier
    if tier == "pro":
        license_jwt = licenses.get("pro")
    elif tier == "enterprise":
        license_jwt = licenses.get("enterprise")
    else:
        # Community tier doesn't require a license
        license_jwt = None

    if license_jwt:
        license_path = Path(os.environ.get("CODE_SCALPEL_DOC_PROJECT_ROOT", "/tmp")) / ".code-scalpel"
        license_file = license_path / f"license_{tier}.jwt"
        license_file.write_text(license_jwt, encoding="utf-8")
        env["CODE_SCALPEL_LICENSE_PATH"] = str(license_file)

    params = StdioServerParameters(
        command=sys.executable,
        args=["-m", "code_scalpel.mcp.server", "--root", str(project_root)],
        env=env,
    )

    async with stdio_client(params) as (read, write):
        async with ClientSession(read, write) as session:
            await session.initialize()
            tools_result = await session.list_tools()

    tool_names = {t.name for t in tools_result.tools}
    return TierTools(tier=tier, tools=set(tool_names))


def _write_matrix(out_path: Path, by_tier: dict[str, TierTools]) -> None:
    out_path.parent.mkdir(parents=True, exist_ok=True)

    # Collect union of all tools we observed.
    all_tools: set[str] = set()
    for tt in by_tier.values():
        all_tools |= tt.tools

    def mark(tool: str, tier: str) -> str:
        return "✅" if tool in by_tier[tier].tools else "❌"

    lines: list[str] = []
    lines.append("# MCP Tools by Tier (Current)")
    lines.append("")
    lines.append("This document is generated from the MCP server tool registry for each tier.")
    lines.append("")
    lines.append("- Generated by: `scripts/generate_mcp_tier_matrix.py`")
    lines.append("")

    # Summary counts
    for tier in TIERS:
        lines.append(f"- {tier}: **{len(by_tier[tier].tools)}** tools")
    lines.append("")

    # Matrix
    lines.append("| MCP Tool ID | Community | Pro | Enterprise |")
    lines.append("|---|---:|---:|---:|")
    for tool in sorted(all_tools):
        lines.append(f"| `{tool}` | {mark(tool, 'community')} | {mark(tool, 'pro')} | {mark(tool, 'enterprise')} |")
    lines.append("")

    lines.append("Legend:")
    lines.append("- ✅ Included in tier")
    lines.append("- ❌ Not included in tier")
    lines.append("")

    out_path.write_text("\n".join(lines).rstrip() + "\n", encoding="utf-8")


async def main() -> int:
    # Use a tiny, empty project root so tools that require a root can still initialize.
    project_root = Path(os.environ.get("CODE_SCALPEL_DOC_PROJECT_ROOT", ""))
    if not project_root:
        project_root = _repo_root() / "evidence" / "mcp_tools_docgen"
        project_root.mkdir(parents=True, exist_ok=True)
        (project_root / "README.txt").write_text(
            "Temporary project root for MCP tier matrix documentation generation.\n",
            encoding="utf-8",
        )

    # Set up licenses (will fail if not available)
    empty_env: dict[str, str] = {}
    env_with_licenses = _setup_licenses_env(empty_env)
    licenses = {
        "pro": env_with_licenses["_TMP_PRO_LICENSE_JWT"],
        "enterprise": env_with_licenses["_TMP_ENTERPRISE_LICENSE_JWT"],
    }

    by_tier: dict[str, TierTools] = {}
    for tier in TIERS:
        by_tier[tier] = await asyncio.wait_for(
            _fetch_tools_for_tier(project_root, tier, licenses),
            timeout=timedelta(seconds=90).total_seconds(),
        )

    out_path = _repo_root() / "docs" / "reference" / "mcp_tools_by_tier.md"
    _write_matrix(out_path, by_tier)

    print(f"Wrote {out_path}")
    return 0


if __name__ == "__main__":
    raise SystemExit(asyncio.run(main()))
