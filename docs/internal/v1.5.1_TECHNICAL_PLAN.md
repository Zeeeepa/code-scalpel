# v1.5.1 "CrossFile" - Technical Implementation Plan

**Version:** 1.0  
**Date:** December 13, 2025  
**Theme:** Multi-File Operations for AI Agents  
**Release Target:** Q1 2026 (January-March)  
**Effort:** ~15 developer-days  
**Risk Level:** High (architectural complexity)

---

## Executive Summary

v1.5.1 extends Code Scalpel with **cross-file awareness**. AI agents will be able to:
1. **Extract code across files** with all callers and callees
2. **Track taint across imports** to find SQL injection/command injection that spans files
3. **Understand import chains** to navigate project dependencies

This is critical for refactoring and security analysis because vulnerabilities rarely exist in isolation—they flow through function calls across module boundaries.

---

## Problem Statement

### Current Limitation (v1.5.0)

```python
# File: views.py
def handle_request(request):
    user_id = request.args['id']  # TAINTED: User input
    return models.get_user(user_id)

# File: models.py
def get_user(user_id):
    query = f"SELECT * FROM users WHERE id={user_id}"
    return db.execute(query)  # SQL INJECTION VULNERABILITY
```

**The Problem:**
- v1.5.0 `security_scan` on `models.py` will find the vulnerability [COMPLETE]
- But `security_scan` on `views.py` alone won't detect that `user_id` is tainted [FAILED]
- AI agents can't know that `handle_request()` has a vulnerability without analyzing `models.py`

### AI Agent Workflow Issue

1. AI reads `views.py` → sees `handle_request(request)` 
2. AI thinks: "This looks safe, just passing to another function"
3. AI doesn't check `models.py` automatically
4. AI applies a change that makes the vulnerability **worse**

### Solution: Project-Scope Analysis

v1.5.1 will provide:
- **Import graph** of the entire project
- **Cross-file extraction** to see callers and callees
- **Inter-procedural taint analysis** to track data flow across files

---

## Architecture

### Component 1: Import Resolution Engine

**Purpose:** Build accurate picture of how modules connect

```
┌─────────────────────────────────────────────┐
│      Import Resolution Engine               │
├─────────────────────────────────────────────┤
│                                             │
│  Input: project_root, entry_point          │
│  Output: ImportGraph                       │
│                                             │
│  ┌──────────────┐  ┌──────────────┐       │
│  │ File Crawler │→ │ AST Parser   │       │
│  └──────────────┘  └──────────────┘       │
│         │                │                 │
│         └────────┬───────┘                 │
│                  ↓                         │
│         ┌──────────────┐                   │
│         │ Build Graph  │                   │
│         │ views → models                   │
│         │ models → db                      │
│         └──────────────┘                   │
│                  ↓                         │
│         ┌──────────────┐                   │
│         │ Validate     │                   │
│         │ (detect cycles)                  │
│         └──────────────┘                   │
│                                             │
└─────────────────────────────────────────────┘
```

**Implementation:**

```python
class ImportGraph:
    """Build and query module import relationships."""
    
    def __init__(self, project_root: str):
        self.project_root = project_root
        self.edges = {}  # module_a -> [module_b, module_c]
        self.symbols = {}  # (module, symbol_name) -> SymbolDef
        
    def build(self, entry_point: str = None):
        """Phase 1: Crawl all Python files and parse imports."""
        for py_file in self._find_python_files():
            module_name = self._path_to_module(py_file)
            imports = self._extract_imports_from_file(py_file)
            self.edges[module_name] = imports
            
    def validate(self):
        """Phase 2: Detect circular imports and report."""
        cycles = self._find_cycles()
        if cycles:
            self.circular_imports = cycles
            return False  # Graceful failure
        return True
        
    def resolve(self, from_module: str, symbol_name: str):
        """Phase 3: Given 'from models import get_user', resolve to actual symbol."""
        # Check if symbol_name is directly in models.py
        # Or if models imports it from elsewhere
        # Return: (actual_module, SymbolDef)
        pass
```

**Key Methods:**

| Method | Purpose | Example |
|--------|---------|---------|
| `build()` | Crawl project and extract all imports | Finds all 47 Python files |
| `validate()` | Check for circular imports | Detects `a→b→c→a` |
| `resolve(module, symbol)` | Trace symbol to source | `resolve('views', 'get_user')` → `('models', SymbolDef)` |
| `topological_sort()` | Order modules by dependency | `[db, models, views]` (safe to analyze) |

**Scope (v1.5.1):**
- [COMPLETE] `from module import func` (direct imports)
- [COMPLETE] `import module` (module imports)
- [COMPLETE] `from . import sibling` (relative imports)
- [COMPLETE] `from ..package import module` (parent imports)
- [FAILED] `importlib.import_module()` (dynamic, can't resolve statically)
- [FAILED] `__import__()` (dynamic)
- [FAILED] `sys.path` manipulation (too complex)

---

### Component 2: Cross-File Extraction

**Purpose:** Extract a symbol with all callers and callees across the project

```python
async def extract_cross_file(
    symbol_name: str,
    project_root: str,
    include_callers: bool = True,
    include_callees: bool = True,
    max_depth: int = None
) -> CrossFileExtraction:
    """Extract a symbol with its cross-file dependencies."""
    
    # Phase 1: Locate the symbol
    symbol_def = graph.find_symbol(symbol_name)
    
    # Phase 2: Find all callers of this symbol
    callers = graph.find_callers(symbol_def)
    
    # Phase 3: Find all functions this symbol calls
    callees = graph.find_callees(symbol_def)
    
    # Phase 4: Extract code
    return CrossFileExtraction(
        target=extract_code(symbol_def),
        callers=[extract_code(c) for c in callers],
        callees=[extract_code(c) for c in callees],
        import_chain=graph.get_import_path(symbol_def),
    )
```

**Example:**

```python
# Usage
result = await extract_cross_file(
    symbol_name="get_user",
    project_root="/myproject",
    include_callers=True,
    include_callees=True
)

# Output
CrossFileExtraction(
    target=SymbolCode(
        name="get_user",
        file="models.py",
        module="models",
        line=42,
        code="def get_user(user_id):\n    query = f\"SELECT...\"\n..."
    ),
    callers=[
        SymbolCode(
            name="handle_request",
            file="views.py",
            module="views",
            line=10,
            code="def handle_request(request):\n    return get_user(...)"
        ),
        SymbolCode(
            name="get_user_profile",
            file="api.py",
            module="api",
            line=88,
            code="def get_user_profile(user_id):\n    return get_user(...)"
        ),
    ],
    callees=[
        SymbolCode(
            name="execute",
            file="db.py",
            module="db",
            line=156,
            code="def execute(query):\n    cursor.execute(query)"
        ),
    ],
    import_chain=[
        "views imports models",
        "models imports db",
        "models imports config"
    ]
)
```

**Test Cases:**

| Case | Scenario | Expected |
|------|----------|----------|
| Single caller | `get_user()` called by `handle_request()` in same project | Returns 1 caller |
| Multiple callers | `get_user()` called by 3 different functions | Returns all 3 |
| Nested calls | `a()` calls `b()` calls `c()` with depth=2 | Returns up to depth 2 |
| Cross-module | `views.py` imports `get_user` from `models.py` | Correctly resolves module |
| Missing import | `from unknown_module import get_user` | Graceful error, continues |

---

### Component 3: Cross-File Taint Tracking

**Purpose:** Track data taint across file boundaries

```
Scenario:
  views.py (source)  →  models.py (propagation)  →  db.py (sink)
  
  user_id is tainted at views.py:10
  ↓
  get_user(user_id) is called at views.py:12
  ↓
  user_id arrives at models.py:42 as function parameter
  ↓
  query = f"SELECT * WHERE id={user_id}" at models.py:44
  ↓
  VULNERABILITY: SQL injection at models.py:44
```

**Architecture:**

```python
class CrossFileTaintTracker:
    """Track taint across module boundaries."""
    
    def __init__(self, project_root: str):
        self.graph = ImportGraph(project_root)
        self.function_sigs = {}  # func_name -> (params, return_taint)
        self.taint_paths = []  # audit trail
        
    def analyze_project(self):
        """Inter-procedural analysis."""
        
        # Phase 1: Build import graph
        self.graph.build()
        self.graph.validate()  # Check for cycles
        
        # Phase 2: Intra-procedural analysis
        # Analyze each module independently first
        for module in self.graph.topological_sort():
            taint_analyzer = TaintAnalyzer(module)
            taint_analyzer.analyze()  # Existing v1.5.0 logic
            self.function_sigs[module] = taint_analyzer.export_signatures()
        
        # Phase 3: Inter-procedural propagation
        # Now propagate taint across function calls
        for module in self.graph.topological_sort():
            self._propagate_taint_in_module(module)
        
        # Phase 4: Report vulnerabilities
        return self._generate_cross_file_vulnerabilities()
        
    def _propagate_taint_in_module(self, module_name: str):
        """Propagate taint through this module's function calls."""
        for call in self._find_function_calls(module_name):
            if call.is_imported():
                # This function is imported from another module
                called_module, called_func = self.graph.resolve(call.name)
                called_sig = self.function_sigs[called_module][called_func]
                
                # If parameter is tainted and return is tainted, propagate
                if called_sig.return_taint == TaintLevel.HIGH:
                    self._mark_return_tainted(call)
```

**Example Output:**

```json
{
  "vulnerability_id": "TAINT_FLOW_SQL_INJECTION",
  "severity": "CRITICAL",
  "title": "SQL Injection via cross-file taint flow",
  "source_location": {
    "file": "views.py",
    "line": 10,
    "code": "user_id = request.args['id']"
  },
  "sink_location": {
    "file": "models.py",
    "line": 44,
    "code": "query = f\"SELECT * FROM users WHERE id={user_id}\""
  },
  "taint_path": [
    {
      "file": "views.py",
      "line": 10,
      "action": "USER_INPUT",
      "variable": "user_id"
    },
    {
      "file": "views.py",
      "line": 12,
      "action": "CALL",
      "function": "get_user",
      "arguments": ["user_id"]
    },
    {
      "file": "models.py",
      "line": 42,
      "action": "RECEIVE",
      "parameter": "user_id"
    },
    {
      "file": "models.py",
      "line": 44,
      "action": "SQL_SINK",
      "code": "execute(query)"
    }
  ],
  "fix_recommendation": "Use parameterized query: cursor.execute(query, (user_id,))"
}
```

---

## Implementation Phases

### Phase 1: Import Resolution (Days 1-5)

**Goal:** Build solid foundation for cross-file analysis

**Tasks:**
1. Create `ImportGraph` class
2. Implement file crawling and import extraction
3. Build import graph (adjacency list)
4. Implement circular import detection
5. Write 40+ tests for import resolution
6. Handle edge cases:
   - `__init__.py` packages
   - Relative imports
   - Aliased imports (`import x as y`)
   - Wildcard imports (`from x import *`)

**Deliverables:**
- `src/code_scalpel/ast_tools/import_resolver.py`
- 40+ test cases in `tests/test_import_resolver.py`
- 95%+ coverage

**Success Criteria:**
- [x] Resolves "from module import func"
- [x] Resolves "import module"
- [x] Resolves relative imports
- [x] Handles __init__.py packages
- [x] Detects circular imports gracefully

---

### Phase 2: Cross-File Extraction (Days 6-10)

**Goal:** MCP tool to extract symbols with callers/callees

**Tasks:**
1. Create `CallGraphAnalyzer` for cross-file calls
2. Implement `find_callers()` using import graph + AST
3. Implement `find_callees()` similarly
4. Create `CrossFileExtraction` result model
5. Add MCP tool wrapper
6. Write 30+ tests

**Deliverables:**
- `src/code_scalpel/ast_tools/cross_file_extractor.py`
- MCP tool in `src/code_scalpel/mcp/server.py`
- 30+ tests in `tests/test_cross_file_extractor.py`
- 95%+ coverage

**Success Criteria:**
- [x] extract_cross_file: Extracts symbol with callers
- [x] extract_cross_file: Extracts symbol with callees
- [x] extract_cross_file: Returns import chain
- [x] extract_cross_file: Works across 3+ files

---

### Phase 3: Cross-File Taint (Days 11-15)

**Goal:** Detect vulnerabilities that span multiple files

**Tasks:**
1. Extend `TaintAnalyzer` to export function signatures
2. Create `CrossFileTaintTracker` class
3. Implement inter-procedural propagation
4. Build taint path reconstruction (for reporting)
5. Write 35+ tests covering:
   - SQL injection across 2 files
   - Command injection across 3 files
   - Return value taint
   - Parameter taint
6. Document with examples

**Deliverables:**
- `src/code_scalpel/security/cross_file_taint.py`
- Extended results model in `src/code_scalpel/models.py`
- 35+ tests in `tests/test_cross_file_taint.py`
- Example in `examples/cross_file_taint_example.py`
- 95%+ coverage

**Success Criteria:**
- [x] Cross-File Taint: Tracks taint through function calls
- [x] Cross-File Taint: Detects SQL injection across 2 files
- [x] Cross-File Taint: Detects command injection across 2 files
- [x] Cross-File Taint: Reports source file and sink file
- [x] Cross-File Taint: Reports full taint propagation path

---

## Test Strategy

### Unit Tests (150+ tests)

| Component | Tests | Coverage |
|-----------|-------|----------|
| ImportGraph | 45 | 100% |
| CallGraphAnalyzer | 35 | 100% |
| CrossFileExtraction | 30 | 100% |
| CrossFileTaintTracker | 40 | 100% |
| **Total** | **150+** | **100%** |

### Integration Tests (30+ tests)

| Scenario | Tests |
|----------|-------|
| Multi-module projects (3-5 files) | 10 |
| Circular import handling | 5 |
| Relative imports | 5 |
| Taint propagation chains | 10 |

### Edge Cases

```python
# Edge case: Symbol not found
extract_cross_file(symbol_name="nonexistent")
# Expected: Clear error message

# Edge case: Circular imports
# a.py imports b.py
# b.py imports a.py
# Expected: Graceful failure, report cycle

# Edge case: Dynamic imports
# importlib.import_module(user_input)
# Expected: Skip, report limitation

# Edge case: Wildcard imports
# from utils import *
# Expected: Resolve what we can, warn about unknowns

# Edge case: Aliased imports
# from models import get_user as fetch_user
# Expected: Correctly resolve to get_user function
```

---

## Risk Mitigation

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|-----------|
| Cross-file analysis too slow (50+ file project) | Medium | High | Implement lazy evaluation, cache import graph |
| False negatives in taint (missed vulnerabilities) | Medium | Critical | Start with single-hop, extensive testing |
| Circular imports crash analyzer | High | High | Explicit cycle detection + graceful failure |
| Dynamic imports can't be resolved | High | Medium | Document limitation, skip gracefully |
| Taint explosion (too many paths) | Medium | High | Implement path bounding, limit to most likely paths |

---

## Success Metrics

### Quality Gates

- [x] All 150+ tests passing
- [x] 95%+ code coverage on new modules
- [x] No regressions in v1.5.0 security detections
- [x] Performance: 50-file project analyzed in < 30 seconds

### Performance Targets

| Operation | Target | Acceptable |
|-----------|--------|-----------|
| Build import graph (50 files) | 2s | < 5s |
| Find all callers (typical function) | 0.5s | < 2s |
| Cross-file taint analysis (50 files) | 10s | < 30s |
| Extract with cross-file context | 1s | < 5s |

---

## Timeline

```
Week 1 (Jan 6-10)     Phase 1: Import Resolution [COMPLETE]
                      - ImportGraph class
                      - File crawling & parsing
                      - 40+ tests

Week 2 (Jan 13-17)    Phase 2: Cross-File Extraction [COMPLETE]
                      - CallGraphAnalyzer
                      - MCP tool integration
                      - 30+ tests

Week 3 (Jan 20-24)    Phase 3: Cross-File Taint [COMPLETE]
                      - Inter-procedural analysis
                      - Taint path reconstruction
                      - 35+ tests

Week 4 (Jan 27-31)    Testing & Documentation
                      - Integration tests
                      - Performance tuning
                      - Release notes & examples

Feb 3               Release v1.5.1 to PyPI
```

---

## Next: v2.0.0 Dependencies

v1.5.1 provides the foundation for v2.0.0 "Polyglot":
- Cross-file analysis will extend to TypeScript, JavaScript, Java
- Same import resolution logic, different AST parsers
- Taint tracking extends to language-specific sinks

---

## Questions for Planning

1. **Scope:** Should v1.5.1 support `sys.path` manipulation? (currently: no)
2. **Performance:** Is 30s acceptable for 50-file analysis, or should we optimize harder?
3. **Error handling:** When taint analysis fails midway, should we report partial results?
4. **Documentation:** Should we provide migration guide for v1.5.0 users?

