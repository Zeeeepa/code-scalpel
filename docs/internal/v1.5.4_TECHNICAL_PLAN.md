# v1.5.4 Technical Plan - Dynamic Import Resolution

**Status:** DRAFT
**Target Release:** v1.5.4
**Theme:** Dynamic Import Resolution

## 1. Executive Summary

This release extends the `ImportResolver` to detect and track dynamic imports created via `importlib.import_module()` and `__import__()`. This is crucial for analyzing modern Python codebases that use plugin systems, lazy loading, and frameworks like Django and Flask.

## 2. Architecture Changes

### 2.1 ImportResolver Extension

We will modify `src/code_scalpel/ast_tools/import_resolver.py` to include a new method `_extract_dynamic_imports` that walks the AST looking for specific call patterns.

```python
class ImportResolver:
    def _extract_dynamic_imports(self, tree: ast.AST, file_path: str):
        # Implementation to detect importlib.import_module and __import__
        pass
```

### 2.2 ImportType Enum Update

We will update the `ImportType` enum (or equivalent structure) to support new types:
- `DYNAMIC`: For `importlib.import_module()`
- `DUNDER`: For `__import__()`
- `LAZY`: For detected but unresolved dynamic imports (e.g., variable names)

### 2.3 Framework Support

We will add specific logic to handle:
- **Django:** Parsing `INSTALLED_APPS` in `settings.py` to find app modules.
- **Flask:** Detecting `Blueprint` registration patterns.

## 3. Implementation Tasks

### Phase 1: Core Dynamic Import Detection (P0)
- [x] Implement `_is_import_module_call` to detect `importlib.import_module`.
- [x] Implement `_is_dunder_import` to detect `__import__`.
- [x] Update `ImportResolver` to store these new import types.
- [x] Add unit tests for basic dynamic import patterns.

### Phase 2: Variable & String Handling (P1)
- [x] Handle string literals in dynamic imports.
- [x] Handle simple variable references (basic local data flow: `var = "mod"`).
- [x] Mark complex/unknown variables as `LAZY` imports.

### Phase 3: Framework Integration (P1/P2)
- [x] Implement Django `INSTALLED_APPS` parser.
- [x] Implement Flask Blueprint detection.
- [x] Add integration tests for sample Django/Flask apps (Django settings + Flask app.register_blueprint).

## 4. Testing Strategy

### 4.1 Unit Tests
- Create `tests/test_dynamic_imports.py`.
- Test cases for:
    - `importlib.import_module("pkg.mod")`
    - `__import__("pkg.mod")`
    - `importlib.import_module(var)` (should be LAZY or resolved if simple)
    - Mixed static and dynamic imports.

### 4.2 Integration Tests
- Use `benchmarks/sample_flask_app.py` and create a `benchmarks/sample_django_app` structure.
- Verify that `crawl_project` correctly identifies dependencies in these apps.

## 5. Release Artifacts

- `release_artifacts/v1.5.4/v1.5.4_dynamic_import_evidence.json`
- `release_artifacts/v1.5.4/dynamic_import_tests.log`
- `release_artifacts/v1.5.4/framework_integration_results.json`
