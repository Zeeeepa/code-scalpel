# **Comparative Analysis of Pattern-Based Static Analysis Architectures: Semgrep, Tree-sitter, and Joern in the Context of AI-Driven Security and Token Efficiency**

## **1\. The Epistemology of Code Representation in Modern Static Analysis**

The domain of Static Application Security Testing (SAST) has historically been defined by a tension between depth of analysis and velocity of execution. This dichotomy has necessitated divergent architectural approaches to the fundamental problem of representing source code as a queryable data structure. At the sophisticated end of the spectrum, tools like Joern construct elaborate graphs that fuse syntax, control flow, and data dependencies, enabling the discovery of complex, multi-stage vulnerabilities. Conversely, the demand for "ludicrous speed" in continuous integration (CI) environments has given rise to lightweight, pattern-based engines like Semgrep, which prioritize syntactic isomorphism and rapid feedback over deep symbolic execution.

The emergence of Large Language Models (LLMs) as active participants in the software development lifecycle has introduced a third, critical dimension to this architectural evaluation: **Token Efficiency**. As AI agents increasingly assume roles in automated remediation and code reasoning, the static analysis tool transitions from a mere reporting engine to a context retrieval system—a "code scalpel" tasked with extracting precise, semantically relevant slices of code to minimize the economic and computational costs of the LLM context window. This report provides an exhaustive technical analysis of these competing architectures, examining the low-level mechanics of Tree-sitter’s incremental parsing, Semgrep’s Generic Abstract Syntax Tree (AST) abstraction, and Joern’s Code Property Graph (CPG), while evaluating their respective efficacies in the era of AI-augmented security.

## **2\. Tree-sitter: The Foundational Engine of Incremental Parsing**

To comprehend the performance characteristics of modern analysis tools, one must first deconstruct the parsing layer. Tree-sitter has established itself as the de facto standard for parsing in the modern developer ecosystem, underpinning technologies ranging from GitHub’s code navigation to the core of the Semgrep engine.1 Its dominance is not merely a function of speed, but a result of specific architectural choices designed to support real-time interactivity.

### **2.1 Generalized LR Parsing and Error Recovery**

Unlike traditional parsers generated by YACC or Bison, which typically utilize Look-Ahead Left-to-Right (LALR) algorithms that are fragile in the face of syntax errors, Tree-sitter employs a Generalized LR (GLR) parsing algorithm.3 This distinction is critical for static analysis in "shift-left" scenarios. In a developer’s Integrated Development Environment (IDE) or during the generation of code by an AI agent, the source text is frequently in an invalid or incomplete state. A traditional parser would halt execution upon encountering a missing semicolon or an unclosed brace, rendering analysis impossible.

Tree-sitter’s GLR approach allows it to handle non-deterministic grammars and, crucially, to perform robust error recovery. When it encounters a syntax error, it does not abort; instead, it produces a Concrete Syntax Tree (CST) that contains specific ERROR nodes while successfully parsing the valid surrounding code.4 This capability enables tools built on Tree-sitter to provide feedback on partial or malformed code, a requirement for real-time "vibe coding" agents that function via the Model Context Protocol (MCP).5

### **2.2 Performance Metrics: The Concrete Syntax Tree**

The performance profile of Tree-sitter is characterized by its ability to update the parse tree incrementally. When a developer modifies a file, Tree-sitter does not re-parse the document from scratch; it identifies the edited range and updates only the affected nodes in the CST. Benchmarks indicate that this approach yields parsing speeds up to **134x faster** than traditional compilers like Dotty for languages such as Scala.6 In optimized scenarios, Tree-sitter is capable of parsing millions of lines of code per second.2

However, the CST produced by Tree-sitter is verbose. It preserves every textual detail of the source code, including whitespace, comments, and optional punctuation. While this fidelity is essential for syntax highlighting, it presents a significant challenge for pattern-based static analysis. A rule designed to match a function call foo(x) would fail if matched directly against a CST where the user has inserted extra whitespace foo( x ), unless the matching logic explicitly accounts for every possible variation of formatting. This verbosity necessitates an abstraction layer to normalize the code structure for effective querying, a role fulfilled by Semgrep’s intermediate representation.

## **3\. Semgrep Architecture: The Generic AST Abstraction**

Semgrep’s architectural innovation lies in its ability to harness the raw speed of Tree-sitter while abstracting away the noise of the CST. It achieves this through a transformation pipeline that converts the language-specific CST into a **Generic Abstract Syntax Tree (Generic AST)**, a unified intermediate representation that normalizes syntactic constructs across different programming languages.7

### **3.1 The OCaml Core and Syntactic Normalization**

The core of the Semgrep engine is written in OCaml, a functional programming language chosen for its efficiency in recursive tree traversal and symbolic manipulation.9 The analysis pipeline proceeds in distinct stages:

1. **Parsing:** The language-specific Tree-sitter parser processes the source file, generating a CST.  
2. **Conversion:** OCaml functions traverse the CST, discarding irrelevant tokens such as whitespace, comments, and mandatory punctuation. Simultaneously, they map language-specific constructs to Generic AST types.8 For instance, a Python list comprehension and a Java Stream map operation might arguably be reduced to similar iteration nodes, though Semgrep primarily focuses on syntactic normalization within the language family rather than deep semantic unification.  
3. **Pattern Matching:** The matching engine operates on this Generic AST using a logic that accommodates code isomorphism.

This architecture enables what is termed **Code-Isomorphic Pattern Matching**. A security engineer can write a rule that looks like standard code—for example, exec(...)—and the engine will match usage patterns such as exec(command) or exec('ls') regardless of spacing or minor syntactic variations. This design occupies a strategic middle ground between simple text search (grep), which lacks structural awareness, and full semantic analysis (like CodeQL), which requires complex query languages.11

### **3.2 Optimization Mechanics: "Ludicrous Speed"**

Semgrep’s performance philosophy is explicitly defined by "picking battles it can win".9 Rather than attempting global pointer analysis or symbolic execution, which entail exponential complexity, Semgrep defaults to intra-file analysis. This constraint ensures that the analysis time remains linear relative to the size of the codebase.

Several key optimizations contribute to its high throughput:

* **Textual Pre-filtering:** Before the expensive process of parsing a file is initiated, Semgrep scans the raw text for string literals required by the active rules. If a rule is designed to detect the function boto3.client, and the string "boto3" is absent from the file, the engine skips parsing entirely. This technique provides a linear speedup proportional to the specificity of the rules.9  
* **Multicore Parallelism:** Recent architectural updates in version 1.124 and beyond have enabled multicore parallel processing by default. This allows the engine to analyze files concurrently across available CPU cores, resulting in scan time reductions of up to **3x** for large monorepos without a corresponding spike in memory usage.13  
* **Lazy Evaluation:** By converting the CST to the Generic AST only when necessary and skipping irrelevant subtrees, the engine minimizes memory allocation. This contrasts with tools that must load the entire program graph into memory before analysis can begin.

**Table 1: Comparative Performance Metrics of Analysis Architectures**

| Metric | Tree-sitter (Raw) | Semgrep OSS | Semgrep Pro (Deep) | Joern (CPG) |
| :---- | :---- | :---- | :---- | :---- |
| **Primary Representation** | Concrete Syntax Tree (CST) | Generic AST | AST \+ Call Graph \+ Taint | Code Property Graph (CPG) |
| **Startup Overhead** | Negligible (\<10ms) | Low (\<1s \- 5s) | Moderate (Pre-processing) | High (Importing Code) |
| **Scan Time (Med. Repo)** | \~100ms | \~10-20 seconds 14 | \~300 seconds 14 | Minutes to Hours |
| **Memory Footprint** | Low (Transient) | Low (Per-file) | High (Whole-program) | High (Graph DB) |
| **Analysis Scope** | Syntactic / Parsing | Intra-file / Intra-procedural | Inter-file / Dataflow | Global / Inter-procedural |
| **Best Use Case** | Editor Highlighting | CI/CD Guardrails | Deep Security Audits | Deep Vulnerability Research |

## **4\. Joern and the Code Property Graph: The Pursuit of Depth**

In direct contrast to Semgrep’s lightweight approach, Joern creates a massive, unified data structure known as the **Code Property Graph (CPG)**. The CPG is a superset of three fundamental program representations: the Abstract Syntax Tree (AST), the Control Flow Graph (CFG), and the Program Dependence Graph (PDG).15

### **4.1 Graph Database and Traversal**

Joern stores this comprehensive graph in a custom graph database called **OverflowDB**. This architecture allows security researchers to model vulnerabilities as graph traversal queries. Using a Scala-based domain-specific language (DSL), an analyst can formulate queries such as: "Identify all variables named x that are tainted by user input and reach the exec function via any valid control flow path".15

The CPG enables **Inter-Procedural Analysis** (IPA) of a depth that exceeds Semgrep’s capabilities. Because the graph connects function calls to their definitions across the entire codebase, Joern can track data flow through complex inheritance hierarchies and polymorphic method calls. This allows it to detect vulnerabilities that depend on the global state of the application, which intra-file analysis would inevitably miss.

### **4.2 The Cost of Construction**

The power of the CPG comes at a steep price in terms of performance. Constructing the CPG requires parsing the entire codebase, resolving symbols, calculating control flow for every function, and determining data dependencies. This "import code" phase is a resource-intensive, blocking operation. Benchmarks on datasets like Securibench Micro demonstrate that Joern requires significantly more memory—often measured in Gigabytes—and initialization time compared to Semgrep’s transient analysis.18 Consequently, while Joern is unparalleled for deep, offline vulnerability research, its latency profile makes it ill-suited for blocking CI/CD pipelines or real-time developer feedback loops.

## **5\. Token Efficiency: The Economic Imperative of AI Agents**

As the software industry integrates LLMs for tasks such as automated bug fixing and vulnerability triage, a new performance metric has eclipsed raw execution speed: **Token Efficiency**. LLMs operate within a finite "context window," and the cost of inference is directly proportional to the number of tokens processed. "Context Stuffing"—the practice of dumping entire files into the prompt—leads to "Context Rot," where the model's reasoning capabilities degrade as the volume of irrelevant information increases.19

### **5.1 Semgrep as a "Code Scalpel" for RAG**

Semgrep has emerged as a critical component in **Retrieval-Augmented Generation (RAG)** workflows because it functions as a "Code Scalpel".21 Unlike naive RAG approaches that chunk code by arbitrary line counts (often breaking semantic boundaries), or vector-based retrieval which can be imprecise, Semgrep can be used to surgically extract specific, semantically complete units of code.

When a Semgrep rule matches a pattern, the tool’s JSON output provides precise AST ranges, including start and end line/column coordinates.23 An AI agent can utilize this structured output to extract *only* the relevant function definitions or variable declarations associated with a finding. For example, if a vulnerability is detected in a function process\_payment, the agent can retrieve the exact 50 lines of that function code rather than the 2,000 lines of the enclosing file.

### **5.2 Architectural Advantages for Context Retrieval**

Research indicates that **AST-based slicing** significantly outperforms full-file loading in terms of token efficiency. By extracting only the dependency chain relevant to a specific bug, token usage can be reduced by over **90%** compared to monolithic loading, without sacrificing the semantic context required for accurate remediation.25

* **Structured JSON Output:** Semgrep’s output is natively structured, providing the metadata (metavariables, file paths, ranges) that an LLM needs to understand the code's location and context without parsing the file itself.23  
* **Model Context Protocol (MCP):** Semgrep supports the Model Context Protocol, allowing IDE agents (such as Cursor or Windsurf) to query the analysis engine directly. An agent can request, "Show me all high-severity issues," and receive a concise JSON payload. It can then request the specific code ranges for those issues, minimizing the input tokens sent to the model inference API.5

**Table 2: Context Extraction Efficiency for AI Agents**

| Feature | Semgrep | Joern | Raw File / Grep |
| :---- | :---- | :---- | :---- |
| **Context Granularity** | High (AST Nodes/Metavariables) | Very High (PDG Slices) | Low (Lines of Text) |
| **Extraction Latency** | Milliseconds/Seconds | Seconds/Minutes | Milliseconds |
| **Output Format** | Structured JSON (LLM-ready) | Graph/Dot/Table (Complex parsing) | Unstructured Text |
| **Token Density** | High (Only relevant logic) | Variable (Graph serialization is verbose) | Low (Includes whitespace/boilerplate) |
| **Agent Integration** | Native MCP Support 5 | Custom scripting required | Basic I/O |

The economic implications are substantial. With input tokens dominating the cost structure of LLM interactions, the ability to reduce context size by an order of magnitude fundamentally alters the ROI of automated security agents. Semgrep’s architecture allows it to serve as a high-speed filter, identifying and extracting the "needle" so the LLM doesn't have to pay to process the entire "haystack".28

## **6\. Inter-Procedural Analysis and Dataflow Limitations**

A critical distinction between the analyzed tools is their capacity for **Inter-Procedural Analysis** (IPA)—the ability to track data flow across function and file boundaries. This capability is often the dividing line between finding simple syntax errors and detecting complex injection vulnerabilities.

### **6.1 Intra-procedural vs. Inter-procedural Scope**

The open-source version of Semgrep (Semgrep OSS) is inherently **intra-procedural**. It analyzes files in isolation. If a variable x is tainted in one file and passed to a function foo(x) defined in another file, Semgrep OSS loses the taint trail. It operates on the assumption that foo is a "black box," potentially leading to false negatives in complex applications.30

In contrast, **Semgrep Pro** introduces cross-file analysis capabilities. It overcomes the performance limitations of global analysis by using **Function Summaries**. Instead of re-analyzing a called function every time it is invoked, the Pro engine analyzes the function once, determines its taint propagation behavior (e.g., "if argument 1 is tainted, the return value is tainted"), and stores this summary. This allows Semgrep Pro to perform inter-procedural taint tracking with a scan time of approximately 300 seconds for medium repositories, significantly faster than the hours required by graph-based tools.32

### **6.2 Deep Reachability in Joern**

While Semgrep Pro approximates global analysis for speed, Joern provides true global reachability. Because the CPG connects all components of the application, Joern queries can traverse complex object-oriented hierarchies and dynamic dispatch scenarios that summary-based approaches might simplify or miss.18 However, this precision is inextricably linked to the high memory and time costs of graph construction, reinforcing Joern’s position as a tool for deep, offline audits rather than rapid developer feedback.

## **7\. Security Implications: Type Confusion and Runtime Validation**

The efficacy of static analysis is not merely a function of architecture but of its ability to detect specific, prevalent vulnerability classes such as **Type Confusion** and the misuse of **Runtime Validation** libraries.

### **7.1 Type Confusion Vulnerabilities**

Type confusion arises when a program allocates a resource using one type but accesses it using an incompatible type, a vulnerability common in C/C++ (via unsafe casts) and dynamic languages like JavaScript (via prototype pollution).34 Semgrep demonstrates high efficacy in detecting the syntactic patterns associated with these vulnerabilities. For instance, rules can be defined to flag assignments to Object.prototype in JavaScript or unsafe pointer casting patterns in Go.36 While Joern’s dataflow engine is theoretically superior for tracking variables through multiple re-assignments, Semgrep’s pattern matching is often sufficient to catch the anti-patterns that lead to these vulnerabilities.

### **7.2 Enforcing Runtime Safety**

Modern secure coding practices rely heavily on runtime validation libraries like **Zod**, **Ajv**, or **io-ts** to enforce type safety at the IO boundary.

* **Performance vs. Ergonomics:** Benchmarks reveal that **Ajv** is significantly faster (higher throughput) than **Zod** due to its code generation approach, yet Zod is often preferred for its developer ergonomics.38  
* **SAST Enforcement:** Semgrep plays a vital role in enforcing the correct usage of these libraries. Rules can be deployed to detect insecure configurations, such as utilizing Zod.any() which bypasses validation, or initializing Ajv without the removeAdditional option, which can leave applications vulnerable to prototype pollution.40  
* **Token Efficiency Connection:** By enforcing strict schemas via Semgrep rules, organizations reduce the variability of data structures in their code. This standardization indirectly improves the predictability of code contexts fed to LLMs, reducing the hallucination rate during code generation tasks.

## **8\. The Convergence: Hybrid AI-Pattern Architectures**

The trajectory of the industry points toward a convergence of deterministic static analysis and probabilistic AI reasoning. Semgrep has integrated GPT-4 based "Assistant" features to perform **Auto-Triage**. Instead of relying solely on syntactic pattern matching, the Assistant analyzes the code context—retrieved efficiently via Semgrep's AST slicing—to determine if a finding is a false positive. This hybrid approach has been shown to reduce triage noise by 20-60%.42

Furthermore, the adoption of the **Model Context Protocol (MCP)** allows Semgrep to function as a real-time sensor for AI agents. As a developer writes code, the agent can query Semgrep via MCP to validate the snippet immediately. Semgrep’s low latency, enabled by Tree-sitter’s incremental parsing and the Generic AST optimization, makes it arguably the only static analysis architecture capable of sustaining this interactive, "typing-time" feedback loop. Tools like CodeQL and Joern, with their heavy build and graph construction phases, are architecturally precluded from this real-time interaction model.

## **9\. Conclusion**

The comparative analysis of Semgrep, Tree-sitter, and Joern reveals an ecosystem defined by distinct but complementary trade-offs between **latency**, **depth**, and **token efficiency**.

**Tree-sitter** serves as the foundational infrastructure, providing the raw parsing speed and error recovery required for modern tooling. **Semgrep** leverages this foundation, applying an OCaml-based Generic AST abstraction to deliver a highly performant, developer-centric analysis engine. Its architecture is uniquely suited for CI/CD integration and, critically, for powering AI agents. By functioning as a "Code Scalpel" that extracts structured, semantic slices of code, Semgrep optimizes the token efficiency of RAG-based security workflows, directly addressing the economic and technical constraints of Large Language Models.

**Joern** retains its superiority for deep, offline vulnerability research where audit depth supersedes execution speed. Its CPG architecture uncovers complex, multi-file dataflow issues that pattern matching may miss, but its resource intensity restricts its utility in the inner developer loop.

Ultimately, the future of static analysis lies in a tiered architecture: real-time, AI-augmented guardrails powered by **Semgrep/Tree-sitter** for immediate feedback and context retrieval, backed by deep, graph-based nightly audits using tools like **Joern** to ensure comprehensive security coverage.

#### **Works cited**

1. SED 1214 Transcript EPISODE 1214 \[INTRODUCTION\] \[00:00:00\] JM:​Static analysis is a type of debugging that identifies de \- Software Engineering Daily, accessed December 30, 2025, [https://softwareengineeringdaily.com/wp-content/uploads/2021/02/SED1214-Isaac-Evans.pdf](https://softwareengineeringdaily.com/wp-content/uploads/2021/02/SED1214-Isaac-Evans.pdf)  
2. Self Hosting a Million-Lines-Per-Second Parser : r/programming \- Reddit, accessed December 30, 2025, [https://www.reddit.com/r/programming/comments/cbvnc1/self\_hosting\_a\_millionlinespersecond\_parser/](https://www.reddit.com/r/programming/comments/cbvnc1/self_hosting_a_millionlinespersecond_parser/)  
3. "Tree-sitter \- a new parsing system for programming tools" by Max Brunsfeld \- YouTube, accessed December 30, 2025, [https://www.youtube.com/watch?v=Jes3bD6P0To](https://www.youtube.com/watch?v=Jes3bD6P0To)  
4. Tree Sitter is amazing. The parsing is fast enough to run on every keystroke. Th... | Hacker News, accessed December 30, 2025, [https://news.ycombinator.com/item?id=26226392](https://news.ycombinator.com/item?id=26226392)  
5. MCP: Model, Context… Propaganda? What security teams need to know about the latest hyped up AI tech | Semgrep, accessed December 30, 2025, [https://semgrep.dev/blog/2025/mcp-model-context-propaganda-what-security-teams-need-to-know-about-the-latest-hyped-up-ai-tech/](https://semgrep.dev/blog/2025/mcp-model-context-propaganda-what-security-teams-need-to-know-about-the-latest-hyped-up-ai-tech/)  
6. fast Scala 3 parsing with tree-sitter \- eed3si9n, accessed December 30, 2025, [https://eed3si9n.com/fast-scala3-parsing-with-tree-sitter/](https://eed3si9n.com/fast-scala3-parsing-with-tree-sitter/)  
7. From Day Zero to Zero Day: Vulnerability Research Excerpt \- Studylib, accessed December 30, 2025, [https://studylib.net/doc/27759007/from-day-zero-to-zero-day-eugene-lim](https://studylib.net/doc/27759007/from-day-zero-to-zero-day-eugene-lim)  
8. Tips for converting CST to AST \- Semgrep, accessed December 30, 2025, [https://semgrep.dev/docs/contributing/cst-to-ast-tips](https://semgrep.dev/docs/contributing/cst-to-ast-tips)  
9. Need for speed: static analysis version \- Semgrep, accessed December 30, 2025, [https://semgrep.dev/blog/2022/static-analysis-speed/](https://semgrep.dev/blog/2022/static-analysis-speed/)  
10. semgrep-core contributing, accessed December 30, 2025, [https://semgrep.dev/docs/contributing/semgrep-core-contributing](https://semgrep.dev/docs/contributing/semgrep-core-contributing)  
11. Compare Semgrep to CodeQL, accessed December 30, 2025, [https://semgrep.dev/docs/faq/comparisons/codeql](https://semgrep.dev/docs/faq/comparisons/codeql)  
12. semgrep/semgrep: Lightweight static analysis for many languages. Find bug variants with patterns that look like source code. \- GitHub, accessed December 30, 2025, [https://github.com/semgrep/semgrep](https://github.com/semgrep/semgrep)  
13. Boosting Security Scan Performance for Monorepos with Multicore Parallel Processing, accessed December 30, 2025, [https://semgrep.dev/blog/2025/boosting-security-scan-performance-for-monorepos-with-multicore-parallel-processing/](https://semgrep.dev/blog/2025/boosting-security-scan-performance-for-monorepos-with-multicore-parallel-processing/)  
14. Benchmarking Semgrep Community Edition Performance Improvements | Blog, accessed December 30, 2025, [https://semgrep.dev/blog/2025/benchmarking-semgrep-performance-improvements/](https://semgrep.dev/blog/2025/benchmarking-semgrep-performance-improvements/)  
15. Why You Should Add Joern to Your Source Code Audit Toolkit | Praetorian, accessed December 30, 2025, [https://www.praetorian.com/blog/why-you-should-add-joern-to-your-source-code-audit-toolkit/](https://www.praetorian.com/blog/why-you-should-add-joern-to-your-source-code-audit-toolkit/)  
16. The Derby of Static Software Testing: Joern vs. CodeQl | elmanto.github.io, accessed December 30, 2025, [https://elmanto.github.io/posts/sast\_derby\_joern\_vs\_codeql](https://elmanto.github.io/posts/sast_derby_joern_vs_codeql)  
17. No pain no gain? Comparing 3 program analysis frameworks for C \- Benjamin Steenhoek, accessed December 30, 2025, [https://benjijang.com/posts/2022/03/no-pain-no-gain/](https://benjijang.com/posts/2022/03/no-pain-no-gain/)  
18. Scalable Language Agnostic Taint Tracking using Explicit Data Dependencies \- arXiv, accessed December 30, 2025, [https://arxiv.org/html/2506.06247v1](https://arxiv.org/html/2506.06247v1)  
19. Context Rot: How Increasing Input Tokens Impacts LLM Performance | Chroma Research, accessed December 30, 2025, [https://research.trychroma.com/context-rot](https://research.trychroma.com/context-rot)  
20. Context Length Management in LLM Applications by cbarkinozer | Medium, accessed December 30, 2025, [https://cbarkinozer.medium.com/context-length-management-in-llm-applications-89bfc210489f](https://cbarkinozer.medium.com/context-length-management-in-llm-applications-89bfc210489f)  
21. Welcome to Scalpel's documentation\! — Scalpel 1.0beta documentation, accessed December 30, 2025, [https://python-scalpel.readthedocs.io/](https://python-scalpel.readthedocs.io/)  
22. How to Beg/Borrow/Steal Your Way to a Cross Platform Bluetooth LE Library, accessed December 30, 2025, [https://nonpolynomial.com/2023/10/30/how-to-beg-borrow-steal-your-way-to-a-cross-platform-bluetooth-le-library/](https://nonpolynomial.com/2023/10/30/how-to-beg-borrow-steal-your-way-to-a-cross-platform-bluetooth-le-library/)  
23. ast-grep \- GitHub Gist, accessed December 30, 2025, [https://gist.github.com/eightHundreds/70c9ec82c2b7ba7140dc2cfaa311e8d1](https://gist.github.com/eightHundreds/70c9ec82c2b7ba7140dc2cfaa311e8d1)  
24. semgrep-interfaces/semgrep\_output\_v1.jsonschema at main \- GitHub, accessed December 30, 2025, [https://github.com/semgrep/semgrep-interfaces/blob/main/semgrep\_output\_v1.jsonschema](https://github.com/semgrep/semgrep-interfaces/blob/main/semgrep_output_v1.jsonschema)  
25. From 150K to 2K Tokens: How Progressive Context Loading Revolutionizes LLM Development Workflows \- William Zujkowski, accessed December 30, 2025, [https://williamzujkowski.github.io/posts/from-150k-to-2k-tokens-how-progressive-context-loading-revolutionizes-llm-development-workflows/](https://williamzujkowski.github.io/posts/from-150k-to-2k-tokens-how-progressive-context-loading-revolutionizes-llm-development-workflows/)  
26. Code vs Serialized AST Inputs for LLM-Based Code Summarization: An Empirical Study (to appear) | Paul Harvey, accessed December 30, 2025, [https://paul-harvey.org/publication/2026-llm-ast-code-summary/](https://paul-harvey.org/publication/2026-llm-ast-code-summary/)  
27. Semgrep \- Awesome MCP Servers, accessed December 30, 2025, [https://mcpservers.org/servers/semgrep/mcp](https://mcpservers.org/servers/semgrep/mcp)  
28. The Hidden Cost of “Hello”: Why Every Token in Your LLM Stack Matters, accessed December 30, 2025, [https://rahulpowar.medium.com/the-hidden-cost-of-hello-why-every-token-in-your-llm-stack-matters-762819125946](https://rahulpowar.medium.com/the-hidden-cost-of-hello-why-every-token-in-your-llm-stack-matters-762819125946)  
29. GenAI FinOps: How Token Pricing Really Works, accessed December 30, 2025, [https://www.finops.org/wg/genai-finops-how-token-pricing-really-works/](https://www.finops.org/wg/genai-finops-how-token-pricing-really-works/)  
30. Semgrep Code overview, accessed December 30, 2025, [https://semgrep.dev/docs/semgrep-code/overview](https://semgrep.dev/docs/semgrep-code/overview)  
31. Perform cross-file analysis \- Semgrep, accessed December 30, 2025, [https://semgrep.dev/docs/semgrep-code/semgrep-pro-engine-intro](https://semgrep.dev/docs/semgrep-code/semgrep-pro-engine-intro)  
32. How we implemented inter-file analysis to find the vulnerabilities that matter \- Semgrep, accessed December 30, 2025, [https://semgrep.dev/events/the-birth-of-semgrep-pro/](https://semgrep.dev/events/the-birth-of-semgrep-pro/)  
33. Deserialization Gadget Chains are not a Pathological Problem in Android:an In-Depth Study of Java Gadget Chains in AOSP \- ResearchGate, accessed December 30, 2025, [https://www.researchgate.net/publication/388954988\_Deserialization\_Gadget\_Chains\_are\_not\_a\_Pathological\_Problem\_in\_Androidan\_In-Depth\_Study\_of\_Java\_Gadget\_Chains\_in\_AOSP](https://www.researchgate.net/publication/388954988_Deserialization_Gadget_Chains_are_not_a_Pathological_Problem_in_Androidan_In-Depth_Study_of_Java_Gadget_Chains_in_AOSP)  
34. type++: Prohibiting Type Confusion With Inline Type Information \- NDSS Symposium, accessed December 30, 2025, [https://www.ndss-symposium.org/wp-content/uploads/2025-53-paper.pdf](https://www.ndss-symposium.org/wp-content/uploads/2025-53-paper.pdf)  
35. JavaScript type confusion: Bypassed input validation (and how to remediate) \- Snyk, accessed December 30, 2025, [https://snyk.io/blog/remediate-javascript-type-confusion-bypassed-input-validation/](https://snyk.io/blog/remediate-javascript-type-confusion-bypassed-input-validation/)  
36. JavaScript prototype pollution \- Security \- MDN Web Docs, accessed December 30, 2025, [https://developer.mozilla.org/en-US/docs/Web/Security/Attacks/Prototype\_pollution](https://developer.mozilla.org/en-US/docs/Web/Security/Attacks/Prototype_pollution)  
37. Using Graphs to Search for Code \- Nick Gregory, accessed December 30, 2025, [https://nickgregory.me/post/2022/07/02/go-code-as-a-graph/](https://nickgregory.me/post/2022/07/02/go-code-as-a-graph/)  
38. Why is Zod so slow? \- LogRocket Blog, accessed December 30, 2025, [https://blog.logrocket.com/why-zod-slow/](https://blog.logrocket.com/why-zod-slow/)  
39. I made 1,000x faster TypeScript Validator Library \- DEV Community, accessed December 30, 2025, [https://dev.to/samchon/typescript-json-is-10-1000x-times-faster-than-zod-and-io-ts-8n6](https://dev.to/samchon/typescript-json-is-10-1000x-times-faster-than-zod-and-io-ts-8n6)  
40. 7 Ways to Combat Prototype Pollution in Your Applications | by Arunangshu Das \- Medium, accessed December 30, 2025, [https://medium.com/@arunangshudas/7-ways-to-combat-prototype-pollution-in-your-applications-7a5eb895bf96](https://medium.com/@arunangshudas/7-ways-to-combat-prototype-pollution-in-your-applications-7a5eb895bf96)  
41. TypeScript vs Zod: Clearing up validation confusion \- LogRocket Blog, accessed December 30, 2025, [https://blog.logrocket.com/when-use-zod-typescript-both-developers-guide/](https://blog.logrocket.com/when-use-zod-typescript-both-developers-guide/)  
42. Semgrep App Security Platform | AI-assisted SAST, SCA and Secrets Detection, accessed December 30, 2025, [https://semgrep.dev/](https://semgrep.dev/)  
43. Our AI Assistant is handling 60% of incoming triage work for customers \- Semgrep, accessed December 30, 2025, [https://semgrep.dev/blog/2025/semgrep-is-confidently-handling-60-of-all-triage-for-users-without-reducing-coverage/](https://semgrep.dev/blog/2025/semgrep-is-confidently-handling-60-of-all-triage-for-users-without-reducing-coverage/)